"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@identity-connect+dapp-sdk@0.10.0_@aptos-labs+ts-sdk@1.30.0_@aptos-labs+wallet-standard@0.2.0_erosxk4jpck6vdia6mixqdmoqa";
exports.ids = ["vendor-chunks/@identity-connect+dapp-sdk@0.10.0_@aptos-labs+ts-sdk@1.30.0_@aptos-labs+wallet-standard@0.2.0_erosxk4jpck6vdia6mixqdmoqa"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@identity-connect+dapp-sdk@0.10.0_@aptos-labs+ts-sdk@1.30.0_@aptos-labs+wallet-standard@0.2.0_erosxk4jpck6vdia6mixqdmoqa/node_modules/@identity-connect/dapp-sdk/dist/index.mjs":
/*!************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@identity-connect+dapp-sdk@0.10.0_@aptos-labs+ts-sdk@1.30.0_@aptos-labs+wallet-standard@0.2.0_erosxk4jpck6vdia6mixqdmoqa/node_modules/@identity-connect/dapp-sdk/dist/index.mjs ***!
  \************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ACDappClient: () => (/* binding */ ACDappClient),\n/* harmony export */   ACKeylessClient: () => (/* binding */ ACKeylessClient),\n/* harmony export */   DAPP_PAIRINGS_WINDOW_STORAGE_KEY: () => (/* binding */ DAPP_PAIRINGS_WINDOW_STORAGE_KEY),\n/* harmony export */   ICDappClient: () => (/* binding */ ICDappClient),\n/* harmony export */   windowStateAccessors: () => (/* binding */ windowStateAccessors)\n/* harmony export */ });\n/* harmony import */ var _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @aptos-connect/wallet-api */ \"(ssr)/./node_modules/.pnpm/@aptos-connect+wallet-api@0.1.5_@aptos-labs+ts-sdk@1.30.0_@aptos-labs+wallet-standard@0.2.0_aptos@1.21.0/node_modules/@aptos-connect/wallet-api/dist/index.mjs\");\n/* harmony import */ var _aptos_connect_web_transport__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @aptos-connect/web-transport */ \"(ssr)/./node_modules/.pnpm/@aptos-connect+web-transport@0.1.0_@aptos-labs+ts-sdk@1.30.0_@aptos-labs+wallet-standard@0.2._rbkqx4le5iilq7vcymgqhcdg6y/node_modules/@aptos-connect/web-transport/dist/index.mjs\");\n/* harmony import */ var _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @aptos-labs/ts-sdk */ \"(ssr)/./node_modules/.pnpm/@aptos-labs+ts-sdk@1.30.0/node_modules/@aptos-labs/ts-sdk/dist/esm/index.mjs\");\n/* harmony import */ var _identity_connect_api__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @identity-connect/api */ \"(ssr)/./node_modules/.pnpm/@identity-connect+api@0.7.0/node_modules/@identity-connect/api/dist/index.mjs\");\n/* harmony import */ var _identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @identity-connect/crypto */ \"(ssr)/./node_modules/.pnpm/@identity-connect+crypto@0.2.4_@aptos-labs+ts-sdk@1.30.0_@aptos-labs+wallet-standard@0.2.0_aptos@1.21.0/node_modules/@identity-connect/crypto/dist/index.mjs\");\n/* harmony import */ var _identity_connect_wallet_api__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @identity-connect/wallet-api */ \"(ssr)/./node_modules/.pnpm/@identity-connect+wallet-api@0.1.1_@aptos-labs+ts-sdk@1.30.0_aptos@1.21.0/node_modules/@identity-connect/wallet-api/dist/index.mjs\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/.pnpm/axios@1.7.9/node_modules/axios/lib/axios.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/.pnpm/axios@1.7.9/node_modules/axios/index.js\");\n// src/ACDappClient.ts\n\n\n\n\n\n\n// src/constants.ts\nvar DEFAULT_FRONTEND_URL = \"https://aptosconnect.app\";\n\n// src/conversion.ts\n\nfunction convertToSerializableArgument(argument) {\n  if (argument === void 0 || argument === null) {\n    return argument;\n  }\n  if (Array.isArray(argument)) {\n    return argument.map((subArgument) => convertToSerializableArgument(subArgument));\n  }\n  if (typeof argument === \"string\" || typeof argument === \"number\" || typeof argument === \"boolean\" || argument instanceof Uint8Array) {\n    return argument;\n  }\n  if (typeof argument === \"bigint\") {\n    return argument.toString();\n  }\n  if (argument instanceof ArrayBuffer) {\n    return new Uint8Array(argument);\n  }\n  if (\"values\" in argument) {\n    return argument.values.map((subArgument) => convertToSerializableArgument(subArgument));\n  }\n  if (\"data\" in argument) {\n    return _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.AccountAddress.from(argument.data).toString();\n  }\n  if (argument.value === void 0) {\n    return void 0;\n  }\n  if (typeof argument.value === \"string\" || typeof argument.value === \"number\" || typeof argument.value === \"boolean\" || argument.value instanceof Uint8Array) {\n    return argument.value;\n  }\n  if (typeof argument.value === \"bigint\") {\n    return argument.value.toString();\n  }\n  throw new Error(\"Unexpected argument\");\n}\nfunction normalizePayloadForIC(payload, aptosConfig) {\n  if (\"bcsToBytes\" in payload) {\n    return payload;\n  }\n  if (\"bytecode\" in payload) {\n    return (0,_aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.generateTransactionPayload)(payload);\n  }\n  if (aptosConfig) {\n    return payload.abi !== void 0 ? (0,_aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.generateTransactionPayloadWithABI)({ ...payload, abi: payload.abi }) : (0,_aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.generateTransactionPayload)({ aptosConfig, ...payload });\n  }\n  const entryFunctionPayload = {\n    arguments: payload.functionArguments.map(convertToSerializableArgument),\n    function: payload.function,\n    type: \"entry_function_payload\",\n    type_arguments: (payload.typeArguments ?? []).map((ta) => ta.toString())\n  };\n  return \"multisigAddress\" in payload ? {\n    multisig_address: _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.AccountAddress.from(payload.multisigAddress).toString(),\n    transaction_payload: entryFunctionPayload,\n    type: \"multisig_payload\"\n  } : entryFunctionPayload;\n}\n\n// src/PairingClient.ts\n\n\n\n\n\n\n// src/errors.ts\nvar SignatureRequestError = class _SignatureRequestError extends Error {\n  constructor(status) {\n    super(status);\n    this.name = \"SignatureRequestError\";\n    Object.setPrototypeOf(this, _SignatureRequestError.prototype);\n  }\n};\nvar UnexpectedSignatureResponseError = class _UnexpectedSignatureResponseError extends Error {\n  constructor(missingFields) {\n    const message = `Missing the following fields: ${missingFields.join(\", \")}`;\n    super(message);\n    this.name = \"UnexpectedSignatureResponseError\";\n    Object.setPrototypeOf(this, _UnexpectedSignatureResponseError.prototype);\n  }\n};\nvar PairingExpiredError = class _PairingExpiredError extends Error {\n  constructor() {\n    super();\n    this.name = \"PairingExpiredError\";\n    Object.setPrototypeOf(this, _PairingExpiredError.prototype);\n  }\n};\nvar UnregisteredDappError = class _UnregisteredDappError extends Error {\n  constructor() {\n    super(\"Dapp ID is invalid or not associated with a registered Dapp.\");\n    this.name = \"UnregisteredDappError\";\n    Object.setPrototypeOf(this, _UnregisteredDappError.prototype);\n  }\n};\n\n// src/state.ts\nvar DAPP_PAIRINGS_WINDOW_STORAGE_KEY = \"icDappPairings\";\nvar windowStateAccessors = {\n  async get(address) {\n    const pairings = await this.getAll();\n    return pairings[address];\n  },\n  async getAll() {\n    const serialized = window.localStorage.getItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY);\n    return serialized ? JSON.parse(serialized) : {};\n  },\n  async update(address, pairing) {\n    const pairings = await this.getAll();\n    if (pairing === void 0) {\n      delete pairings[address];\n    } else {\n      pairings[address] = pairing;\n    }\n    const newSerialized = JSON.stringify(pairings);\n    window.localStorage.setItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY, newSerialized);\n  }\n};\n\n// src/utils.ts\nvar SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS = [\n  \"address\",\n  \"application\",\n  \"chainId\",\n  \"fullMessage\",\n  \"message\",\n  \"nonce\",\n  \"prefix\",\n  \"signature\"\n];\nfunction validateSignMessageResponse(response) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter((field) => !providedFields.has(field));\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\nvar SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS = [\"hash\"];\nfunction validateSignAndSubmitTransactionResponse(response) {\n  const providedFields = new Set(Object.keys(response));\n  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(\n    (field) => !providedFields.has(field)\n  );\n  if (missingFields.length > 0) {\n    throw new UnexpectedSignatureResponseError(missingFields);\n  }\n}\n\n// src/PairingClient.ts\nvar API_VERSION = \"0.2.0\";\nvar SIGNING_REQUEST_POLLING_INTERVAL = 2500;\nvar SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\\S+ to be )?(\\d+)/;\nasync function waitFor(milliseconds) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, milliseconds);\n  });\n}\nasync function withRetries(requestFn, onError, retries = 1) {\n  for (let i = 0; i < retries; i += 1) {\n    try {\n      return await requestFn();\n    } catch (err) {\n      onError(err);\n    }\n  }\n  return requestFn();\n}\nvar ACPairingClient = class {\n  constructor({\n    accessors = windowStateAccessors,\n    axiosConfig,\n    defaultNetworkName = _identity_connect_api__WEBPACK_IMPORTED_MODULE_3__.NetworkName.MAINNET\n  } = {}) {\n    // endregion\n    this.onDisconnectListeners = /* @__PURE__ */ new Set();\n    this.accessors = accessors;\n    this.defaultNetworkName = defaultNetworkName;\n    this.axiosInstance = axios__WEBPACK_IMPORTED_MODULE_6__[\"default\"].create({\n      baseURL: DEFAULT_FRONTEND_URL,\n      ...axiosConfig\n    });\n    const isClientSideRendering = typeof window !== \"undefined\";\n    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : void 0;\n  }\n  async getPairing(id) {\n    const response = await this.axiosInstance.get(`v1/pairing/${id}/`);\n    return response.data.data.pairing;\n  }\n  async syncFirstPairing() {\n    const pairings = await this.accessors.getAll();\n    const firstPairing = Object.values(pairings)[0];\n    if (firstPairing === void 0) {\n      return;\n    }\n    try {\n      const { dappSpecificWallet, maxDappSequenceNumber } = await this.getPairing(firstPairing.pairingId);\n      await this.accessors.update(firstPairing.accountAddress, {\n        ...firstPairing,\n        currSequenceNumber: maxDappSequenceNumber,\n        dappWalletId: dappSpecificWallet?.id\n      });\n    } catch (err) {\n      await this.accessors.update(firstPairing.accountAddress, void 0);\n    }\n  }\n  async createSigningRequest(pairing, type, networkName, requestBody) {\n    const dappEd25519SecretKey = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.decodeBase64)(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.decodeBase64)(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.decodeBase64)(pairing.accountTransportEd25519PublicKeyB64);\n    let sequenceNumber = pairing.currSequenceNumber + 1;\n    return withRetries(\n      async () => {\n        const requestEnvelope = await (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.encryptAndSignEnvelope)(\n          (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.toKey)(dappEd25519SecretKey, _identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.KeyTypes.Ed25519SecretKey),\n          (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.toKey)(dappEd25519PublicKey, _identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.KeyTypes.Ed25519PublicKey),\n          (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.toKey)(accountTransportEd25519PublicKey, _identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.KeyTypes.Ed25519PublicKey),\n          sequenceNumber,\n          { apiVersion: API_VERSION, networkName, requestType: type },\n          requestBody\n        );\n        const response = await this.axiosInstance.post(\n          `v1/pairing/${pairing.pairingId}/signing-request/`,\n          requestEnvelope\n        );\n        await this.accessors.update(pairing.accountAddress, {\n          ...pairing,\n          currSequenceNumber: sequenceNumber\n        });\n        return response.data.data.signingRequest;\n      },\n      (err) => {\n        if ((0,axios__WEBPACK_IMPORTED_MODULE_7__.isAxiosError)(err)) {\n          const errorMessage = err.response?.data?.message;\n          const expectedSequenceNumber = errorMessage?.match(SEQUENCE_NUMBER_MISMATCH_PATTERN)?.[1];\n          if (expectedSequenceNumber !== void 0) {\n            sequenceNumber = Number(expectedSequenceNumber);\n            return;\n          }\n        }\n        throw err;\n      }\n    );\n  }\n  async getSigningRequest(id) {\n    const response = await this.axiosInstance.get(\n      `v1/signing-request/${id}/`,\n      {\n        validateStatus: (status) => status === 200 || status === 404\n      }\n    );\n    return response.data?.data?.signingRequest;\n  }\n  async deletePairing(pairingId, secretKey, publicKey) {\n    const requestEnvelope = await (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.encryptAndSignEnvelope)(\n      secretKey,\n      publicKey,\n      publicKey,\n      0,\n      // ignored\n      {},\n      {}\n    );\n    await this.axiosInstance.post(\n      `v1/pairing/${pairingId}/delete/`,\n      requestEnvelope,\n      { validateStatus: (status) => status === 204 || status === 404 }\n    );\n  }\n  async cancelSigningRequest(pairing, id) {\n    const sequenceNumber = pairing.currSequenceNumber;\n    const dappEd25519SecretKey = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.decodeBase64)(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.decodeBase64)(pairing.dappEd25519PublicKeyB64);\n    const accountTransportEd25519PublicKey = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.decodeBase64)(pairing.accountTransportEd25519PublicKeyB64);\n    const requestEnvelope = await (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.encryptAndSignEnvelope)(\n      (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.toKey)(dappEd25519SecretKey, _identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.KeyTypes.Ed25519SecretKey),\n      (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.toKey)(dappEd25519PublicKey, _identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.KeyTypes.Ed25519PublicKey),\n      (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.toKey)(accountTransportEd25519PublicKey, _identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.KeyTypes.Ed25519PublicKey),\n      sequenceNumber + 1,\n      {},\n      {}\n    );\n    const response = await this.axiosInstance.patch(\n      `v1/signing-request/${id}/cancel/`,\n      requestEnvelope\n    );\n    await this.accessors.update(pairing.accountAddress, {\n      ...pairing,\n      currSequenceNumber: sequenceNumber + 1\n    });\n    return response.data.data.signingRequest;\n  }\n  async signRequest(address, type, requestBody, { cancelToken, networkName } = {}) {\n    await this.initPromise;\n    const pairing = await this.accessors.get(address);\n    if (pairing === void 0) {\n      throw new Error(\"The requested account is not paired\");\n    }\n    let signingRequest;\n    try {\n      signingRequest = await this.createSigningRequest(\n        pairing,\n        type,\n        networkName || this.defaultNetworkName,\n        requestBody\n      );\n      while (signingRequest.status === \"PENDING\") {\n        await waitFor(SIGNING_REQUEST_POLLING_INTERVAL);\n        if (cancelToken?.cancelled) {\n          signingRequest.status = _identity_connect_api__WEBPACK_IMPORTED_MODULE_3__.SigningRequestStatus.CANCELLED;\n          break;\n        }\n        signingRequest = await this.getSigningRequest(signingRequest.id) ?? signingRequest;\n      }\n    } catch (err) {\n      if ((0,axios__WEBPACK_IMPORTED_MODULE_7__.isAxiosError)(err) && err.code === \"404\") {\n        await this.accessors.update(address, void 0);\n        for (const listener of this.onDisconnectListeners) {\n          listener(address);\n        }\n        throw new PairingExpiredError();\n      }\n      throw err;\n    }\n    if (signingRequest.status !== \"APPROVED\") {\n      throw new SignatureRequestError(signingRequest.status);\n    }\n    const decrypted = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.decryptEnvelope)(\n      (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.toKey)((0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.decodeBase64)(pairing.accountTransportEd25519PublicKeyB64), _identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.KeyTypes.Ed25519PublicKey),\n      (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.toKey)((0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.decodeBase64)(pairing.dappEd25519SecretKeyB64), _identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.KeyTypes.Ed25519SecretKey),\n      signingRequest.responseEnvelope\n    );\n    return decrypted.privateMessage;\n  }\n  // region Public API\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async addPairing({ publicKey, secretKey }, finalizedPairing) {\n    await this.accessors.update(finalizedPairing.account.accountAddress, {\n      accountAddress: finalizedPairing.account.accountAddress,\n      accountAlias: finalizedPairing.account.userSubmittedAlias ?? void 0,\n      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,\n      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,\n      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,\n      dappEd25519PublicKeyB64: (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.encodeBase64)(publicKey.key),\n      dappEd25519SecretKeyB64: (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.encodeBase64)(secretKey.key),\n      dappWalletId: finalizedPairing.dappSpecificWalletId,\n      pairingId: finalizedPairing.id\n    });\n  }\n  async disconnect(address) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === void 0) {\n      throw new Error(\"The specified account is not paired\");\n    }\n    const dappEd25519SecretKey = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.decodeBase64)(pairing.dappEd25519SecretKeyB64);\n    const dappEd25519PublicKey = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.decodeBase64)(pairing.dappEd25519PublicKeyB64);\n    await this.deletePairing(\n      pairing.pairingId,\n      (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.toKey)(dappEd25519SecretKey, _identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.KeyTypes.Ed25519SecretKey),\n      (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.toKey)(dappEd25519PublicKey, _identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.KeyTypes.Ed25519PublicKey)\n    );\n    await this.accessors.update(address, void 0);\n    for (const listener of this.onDisconnectListeners) {\n      listener(address);\n    }\n  }\n  async signMessage(address, args, options) {\n    const response = await this.signRequest(\n      address,\n      _identity_connect_api__WEBPACK_IMPORTED_MODULE_3__.SigningRequestTypes.SIGN_MESSAGE,\n      args,\n      options\n    );\n    validateSignMessageResponse(response);\n    return response;\n  }\n  async signTransaction(address, args, options) {\n    const serializedRequestArgs = (0,_identity_connect_wallet_api__WEBPACK_IMPORTED_MODULE_5__.serializeSignTransactionRequestArgs)(args);\n    const serializedResponseArgs = await this.signRequest(address, _identity_connect_api__WEBPACK_IMPORTED_MODULE_3__.SigningRequestTypes.SIGN_TRANSACTION, serializedRequestArgs, options);\n    return (0,_identity_connect_wallet_api__WEBPACK_IMPORTED_MODULE_5__.deserializeSignTransactionResponseArgs)(serializedResponseArgs);\n  }\n  // endregion\n  async signAndSubmitTransaction(address, args, options) {\n    const serializedRequestArgs = (0,_identity_connect_wallet_api__WEBPACK_IMPORTED_MODULE_5__.serializeSignAndSubmitTransactionRequestArgs)(args);\n    try {\n      const responseArgs = await this.signRequest(address, _identity_connect_api__WEBPACK_IMPORTED_MODULE_3__.SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION, serializedRequestArgs, options);\n      validateSignAndSubmitTransactionResponse(responseArgs);\n      return responseArgs;\n    } catch (e) {\n      if (e instanceof axios__WEBPACK_IMPORTED_MODULE_7__.AxiosError && e.response?.data?.message) {\n        throw new Error(e.response?.data?.message);\n      }\n      throw e;\n    }\n  }\n  async getConnectedAccounts() {\n    await this.initPromise;\n    const pairings = await this.accessors.getAll();\n    return Object.values(pairings).map(\n      ({ accountAddress, accountEd25519PublicKeyB64, accountPublicKeyB64 }) => ({\n        address: _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.AccountAddress.from(accountAddress),\n        publicKey: accountPublicKeyB64 !== void 0 ? (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.deserializePublicKeyB64)(accountPublicKeyB64) : (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.deserializeEd25519PublicKeyB64)(accountEd25519PublicKeyB64)\n      })\n    );\n  }\n  onDisconnect(listener) {\n    this.onDisconnectListeners.add(listener);\n    return () => this.onDisconnectListeners.delete(listener);\n  }\n};\n\n// src/ACDappClient.ts\nvar ACDappClient = class {\n  constructor({\n    backendBaseURL,\n    dappId,\n    dappImageURI,\n    dappName,\n    defaultNetworkName = _identity_connect_api__WEBPACK_IMPORTED_MODULE_3__.NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = \"google\"\n  } = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title\n    };\n    this.transport = new _aptos_connect_web_transport__WEBPACK_IMPORTED_MODULE_1__.WebWalletTransport(frontendBaseURL, provider);\n    this.dappId = dappId;\n    this.pairingClient = new ACPairingClient({\n      axiosConfig: {\n        baseURL: backendBaseURL ?? frontendBaseURL\n      },\n      defaultNetworkName\n    });\n  }\n  // region Public API\n  async getKeylessAccounts() {\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async getIcAccounts() {\n    return this.pairingClient.getConnectedAccounts() ?? [];\n  }\n  async isIcAccount(address) {\n    const icAccounts = await this.getIcAccounts();\n    return icAccounts.find((account) => account.address.equals(_aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.AccountAddress.from(address))) !== void 0;\n  }\n  async getConnectedAccounts() {\n    const keylessAccounts = await this.getKeylessAccounts();\n    const icAccounts = await this.getIcAccounts();\n    return [...keylessAccounts, ...icAccounts];\n  }\n  async disconnect(address) {\n    if (await this.isIcAccount(address)) {\n      const stringAddress = _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.AccountAddress.from(address).toString();\n      await this.pairingClient.disconnect(stringAddress);\n    } else {\n      const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.DisconnectRequest.serialize(this.dappInfo);\n      await this.transport.sendRequest(serializedRequest);\n    }\n  }\n  async connect({\n    claimOptions,\n    preferredWalletName\n  } = {}) {\n    const dappKeypair = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.createEd25519KeyPair)();\n    const injectedPreferredWalletName = typeof window !== \"undefined\" ? window.AC_PREFERRED_WALLET_NAME : void 0;\n    const requestArgs = {\n      claimOptions,\n      dappEd25519PublicKeyB64: (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.encodeBase64)(dappKeypair.publicKey.key),\n      dappId: this.dappId,\n      preferredWalletName: preferredWalletName ?? injectedPreferredWalletName\n    };\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.ConnectRequest.serialize(this.dappInfo, requestArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.ConnectResponse.deserialize(serializedResponse);\n    if (response.args.status === \"approved\") {\n      const { account, pairing } = response.args.args;\n      if (pairing) {\n        await this.pairingClient.addPairing(dappKeypair, pairing);\n      }\n      return (0,_aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.makeUserApproval)({ account });\n    }\n    return response.args;\n  }\n  async signMessage(args) {\n    const { signerAddress } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const { chainId } = args;\n      const network = (0,_aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.chainIdToNetwork)(chainId);\n      let message;\n      let nonce;\n      try {\n        message = new TextDecoder().decode(args.message);\n        nonce = new TextDecoder().decode(args.nonce);\n      } catch (err) {\n        throw new Error(\"Only UTF-8 encoded text is supported when using IC\");\n      }\n      const { fullMessage, signature: hexSignature } = await this.pairingClient.signMessage(\n        signerAddress.toString(),\n        {\n          address: true,\n          application: true,\n          chainId: true,\n          message,\n          nonce\n        },\n        { networkName: network }\n      );\n      const signatureBytes = _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.Hex.fromHexInput(hexSignature).toUint8Array();\n      const signature = signatureBytes.length === _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.Ed25519Signature.LENGTH ? new _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.Ed25519Signature(signatureBytes) : _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.AnySignature.deserialize(new _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.Deserializer(signatureBytes));\n      return (0,_aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.makeUserApproval)({\n        fullMessage,\n        signature\n      });\n    }\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signTransaction(args) {\n    const normalizedArgs = \"transaction\" in args ? _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignTransactionRequest.normalizeArgs(args) : args;\n    const { signerAddress } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const {\n        expirationSecondsFromNow,\n        expirationTimestamp,\n        feePayer,\n        gasUnitPrice,\n        maxGasAmount,\n        network,\n        payload,\n        secondarySigners,\n        sender,\n        sequenceNumber\n      } = normalizedArgs;\n      if (feePayer !== void 0) {\n        throw new Error(\"Sponsored transaction not currently supported\");\n      }\n      if (secondarySigners && secondarySigners.length > 0) {\n        throw new Error(\"Multi-agent transactions not currently supported\");\n      }\n      if (!(\"bcsToBytes\" in payload)) {\n        throw new Error(\"Payload input format is only supported with Keyless accounts.\");\n      }\n      const responseArgs = await this.pairingClient.signTransaction(\n        signerAddress.toString(),\n        {\n          options: {\n            expirationSecondsFromNow,\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount,\n            sender: sender?.address.toString(),\n            sequenceNumber: sequenceNumber !== void 0 ? Number(sequenceNumber) : void 0\n          },\n          payload\n        },\n        {\n          networkName: network\n        }\n      );\n      return (0,_aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.makeUserApproval)({\n        authenticator: responseArgs.accountAuthenticator,\n        rawTransaction: responseArgs.rawTxn\n      });\n    }\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signAndSubmitTransaction(args) {\n    const { signerAddress } = args;\n    if (await this.isIcAccount(signerAddress)) {\n      const { expirationTimestamp, feePayer, gasUnitPrice, maxGasAmount, network } = args;\n      const aptosConfig = new _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.AptosConfig({ network });\n      let convertedArgs;\n      if (feePayer !== void 0) {\n        const payload = await normalizePayloadForIC(args.payload, aptosConfig);\n        const rawTxn = await (0,_aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.generateRawTransaction)({\n          aptosConfig,\n          feePayerAddress: feePayer.address,\n          options: {\n            gasUnitPrice,\n            maxGasAmount\n          },\n          payload,\n          sender: signerAddress\n        });\n        convertedArgs = {\n          feePayerAuthenticator: feePayer.authenticator,\n          rawTxn: new _aptos_labs_ts_sdk__WEBPACK_IMPORTED_MODULE_2__.FeePayerRawTransaction(rawTxn, [], feePayer.address)\n        };\n      } else {\n        const payload = normalizePayloadForIC(args.payload);\n        convertedArgs = {\n          options: {\n            expirationTimestamp,\n            gasUnitPrice,\n            maxGasAmount\n          },\n          payload\n        };\n      }\n      const { hash } = await this.pairingClient.signAndSubmitTransaction(signerAddress.toString(), convertedArgs, {\n        networkName: network\n      });\n      return (0,_aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.makeUserApproval)({ txnHash: hash });\n    }\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  // endregion\n};\n\n// src/ICDappClient.ts\n\n\n\n// src/prompt.ts\nvar DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };\nvar PROMPT_POLLER_INTERVAL = 500;\nfunction openPrompt(url, size = DEFAULT_PROMPT_SIZE) {\n  const { height, width } = size;\n  const options = {\n    height,\n    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),\n    popup: true,\n    top: window.screenTop + Math.round((window.outerHeight - height) / 2),\n    width\n  };\n  const strOptions = Object.entries(options).map(([key, value]) => `${key}=${JSON.stringify(value)}`).reduce((acc, entry) => `${acc}, ${entry}`);\n  const href = url instanceof URL ? url.href : url;\n  const promptWindow = window.open(href, void 0, strOptions);\n  if (promptWindow === null) {\n    throw new Error(\"Couldn't open prompt\");\n  }\n  return promptWindow;\n}\nasync function waitForPromptResponse(promptWindow) {\n  return new Promise((resolve) => {\n    const listeners = {\n      onMessage: (message) => {\n        if (message.source !== promptWindow) {\n          return;\n        }\n        window.removeEventListener(\"message\", listeners.onMessage);\n        clearTimeout(listeners.promptPollerId);\n        resolve({\n          args: message.data,\n          status: \"approved\"\n        });\n      },\n      promptPollerId: setInterval(() => {\n        if (promptWindow.closed) {\n          window.removeEventListener(\"message\", listeners.onMessage);\n          clearTimeout(listeners.promptPollerId);\n          resolve({\n            status: \"dismissed\"\n          });\n        }\n      }, PROMPT_POLLER_INTERVAL)\n    };\n    window.addEventListener(\"message\", listeners.onMessage);\n  });\n}\n\n// src/ICDappClient.ts\nvar ICDappClient = class extends ACPairingClient {\n  constructor(dappId, { frontendBaseURL = DEFAULT_FRONTEND_URL, ...pairingClientConfig } = {}) {\n    super(pairingClientConfig);\n    this.dappId = dappId;\n    this.frontendBaseURL = frontendBaseURL;\n  }\n  async createPairingRequest(dappEd25519PublicKeyB64) {\n    try {\n      const response = await this.axiosInstance.post(\"v1/pairing/\", {\n        dappEd25519PublicKeyB64,\n        dappId: this.dappId\n      });\n      return response.data.data.pairing;\n    } catch (err) {\n      if ((0,axios__WEBPACK_IMPORTED_MODULE_7__.isAxiosError)(err) && err.response?.data?.message === \"Dapp not found\") {\n        throw new UnregisteredDappError();\n      }\n      throw err;\n    }\n  }\n  // region Public API\n  /**\n   * Requests a connection to an account (internally known as pairing).\n   * @returns either the address of the connected account, or undefined if the\n   * connection was cancelled.\n   */\n  async connect() {\n    const { publicKey, secretKey } = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.createEd25519KeyPair)();\n    const dappEd25519PublicKeyB64 = (0,_identity_connect_crypto__WEBPACK_IMPORTED_MODULE_4__.encodeBase64)(publicKey.key);\n    const url = new URL(`${this.frontendBaseURL}/pairing`);\n    const promptWindow = await openPrompt(url.href);\n    let pairingId;\n    try {\n      const pendingPairing = await this.createPairingRequest(dappEd25519PublicKeyB64);\n      pairingId = pendingPairing.id;\n    } catch (err) {\n      promptWindow.close();\n      throw err;\n    }\n    url.searchParams.set(\"pairingId\", pairingId);\n    promptWindow.location.href = url.href;\n    const promptResponse = await waitForPromptResponse(promptWindow);\n    if (promptResponse.status === \"dismissed\") {\n      void this.deletePairing(pairingId, secretKey, publicKey);\n      return void 0;\n    }\n    const finalizedPairing = promptResponse.args;\n    await this.addPairing({ publicKey, secretKey }, finalizedPairing);\n    return finalizedPairing.account.accountAddress;\n  }\n  async offboard(address) {\n    const pairing = await this.accessors.get(address);\n    if (pairing === void 0) {\n      throw new Error(\"This account is not paired\");\n    }\n    const walletId = pairing.dappWalletId;\n    if (walletId === void 0) {\n      throw new Error(\"This account cannot be offboarded\");\n    }\n    const url = new URL(`${this.frontendBaseURL}/offboarding?walletId=${walletId}`);\n    const promptWindow = openPrompt(url);\n    const response = await waitForPromptResponse(promptWindow);\n    if (response.status === \"approved\" && response.args.offboarded) {\n      this.disconnect(address);\n      return true;\n    }\n    return false;\n  }\n  // endregion\n};\n\n// src/KeylessClient.ts\n\n\n\nvar ACKeylessClient = class {\n  constructor({\n    dappImageURI,\n    dappName,\n    defaultNetworkName = _identity_connect_api__WEBPACK_IMPORTED_MODULE_3__.NetworkName.MAINNET,\n    frontendBaseURL = DEFAULT_FRONTEND_URL,\n    provider = \"google\"\n  } = {}) {\n    this.defaultNetworkName = defaultNetworkName;\n    this.dappInfo = {\n      domain: window.location.origin,\n      imageURI: dappImageURI,\n      name: dappName ?? document.title\n    };\n    this.transport = new _aptos_connect_web_transport__WEBPACK_IMPORTED_MODULE_1__.WebWalletTransport(frontendBaseURL, provider);\n  }\n  // region Public API\n  async isConnected() {\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.IsConnectedRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.IsConnectedResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async getConnectedAccounts() {\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.GetConnectedAccountsRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.GetConnectedAccountsResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async disconnect() {\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.DisconnectRequest.serialize(this.dappInfo);\n    await this.transport.sendRequest(serializedRequest);\n  }\n  async connect() {\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.ConnectRequest.serialize(this.dappInfo);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.ConnectResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signMessage(args) {\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignMessageRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignMessageResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signTransaction(args) {\n    const normalizedArgs = \"transaction\" in args ? _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignTransactionRequest.normalizeArgs(args) : args;\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  async signAndSubmitTransaction(args) {\n    const serializedRequest = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);\n    const serializedResponse = await this.transport.sendRequest(serializedRequest);\n    const response = _aptos_connect_wallet_api__WEBPACK_IMPORTED_MODULE_0__.SignAndSubmitTransactionResponse.deserialize(serializedResponse);\n    return response.args;\n  }\n  // endregion\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGlkZW50aXR5LWNvbm5lY3QrZGFwcC1zZGtAMC4xMC4wX0BhcHRvcy1sYWJzK3RzLXNka0AxLjMwLjBfQGFwdG9zLWxhYnMrd2FsbGV0LXN0YW5kYXJkQDAuMi4wX2Vyb3N4azRqcGNrNnZkaWE2bWl4cWRtb3FhL25vZGVfbW9kdWxlcy9AaWRlbnRpdHktY29ubmVjdC9kYXBwLXNkay9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFlbUM7QUFDK0I7QUFVdEM7QUFDd0M7QUFDMkI7O0FBRS9GO0FBQ0E7O0FBRUE7QUFLNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEVBQTBCO0FBQ3JDO0FBQ0E7QUFDQSxvQ0FBb0MscUZBQWlDLEdBQUcsOEJBQThCLElBQUksOEVBQTBCLEdBQUcseUJBQXlCO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOERBQWM7QUFDcEM7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUN1RTtBQUt4QztBQVVHO0FBS0k7QUFDa0I7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHlCQUF5QjtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QUM3QztBQUNBLHFCQUFxQixzRUFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlFQUFtQjtBQUNqRDtBQUNBLHFCQUFxQiwwRUFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDZFQUF1QjtBQUMxRSw4QkFBOEIsNkVBQXVCO0FBQ3JEO0FBQ0EscUJBQXFCLDhFQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0ZBQWdDO0FBQzlEO0FBQ0EscUJBQXFCLHVGQUFpQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQU9FO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hcnQzbWlzb3JhY2xlLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BpZGVudGl0eS1jb25uZWN0K2RhcHAtc2RrQDAuMTAuMF9AYXB0b3MtbGFicyt0cy1zZGtAMS4zMC4wX0BhcHRvcy1sYWJzK3dhbGxldC1zdGFuZGFyZEAwLjIuMF9lcm9zeGs0anBjazZ2ZGlhNm1peHFkbW9xYS9ub2RlX21vZHVsZXMvQGlkZW50aXR5LWNvbm5lY3QvZGFwcC1zZGsvZGlzdC9pbmRleC5tanM/ODJhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvQUNEYXBwQ2xpZW50LnRzXG5pbXBvcnQge1xuICBjaGFpbklkVG9OZXR3b3JrLFxuICBDb25uZWN0UmVxdWVzdCxcbiAgQ29ubmVjdFJlc3BvbnNlLFxuICBEaXNjb25uZWN0UmVxdWVzdCxcbiAgR2V0Q29ubmVjdGVkQWNjb3VudHNSZXF1ZXN0LFxuICBHZXRDb25uZWN0ZWRBY2NvdW50c1Jlc3BvbnNlLFxuICBtYWtlVXNlckFwcHJvdmFsLFxuICBTaWduQW5kU3VibWl0VHJhbnNhY3Rpb25SZXF1ZXN0LFxuICBTaWduQW5kU3VibWl0VHJhbnNhY3Rpb25SZXNwb25zZSxcbiAgU2lnbk1lc3NhZ2VSZXF1ZXN0LFxuICBTaWduTWVzc2FnZVJlc3BvbnNlLFxuICBTaWduVHJhbnNhY3Rpb25SZXF1ZXN0LFxuICBTaWduVHJhbnNhY3Rpb25SZXNwb25zZVxufSBmcm9tIFwiQGFwdG9zLWNvbm5lY3Qvd2FsbGV0LWFwaVwiO1xuaW1wb3J0IHsgV2ViV2FsbGV0VHJhbnNwb3J0IH0gZnJvbSBcIkBhcHRvcy1jb25uZWN0L3dlYi10cmFuc3BvcnRcIjtcbmltcG9ydCB7XG4gIEFjY291bnRBZGRyZXNzIGFzIEFjY291bnRBZGRyZXNzMyxcbiAgQW55U2lnbmF0dXJlLFxuICBBcHRvc0NvbmZpZyBhcyBBcHRvc0NvbmZpZzIsXG4gIERlc2VyaWFsaXplcixcbiAgRWQyNTUxOVNpZ25hdHVyZSxcbiAgRmVlUGF5ZXJSYXdUcmFuc2FjdGlvbixcbiAgZ2VuZXJhdGVSYXdUcmFuc2FjdGlvbixcbiAgSGV4XG59IGZyb20gXCJAYXB0b3MtbGFicy90cy1zZGtcIjtcbmltcG9ydCB7IE5ldHdvcmtOYW1lIGFzIE5ldHdvcmtOYW1lMiB9IGZyb20gXCJAaWRlbnRpdHktY29ubmVjdC9hcGlcIjtcbmltcG9ydCB7IGNyZWF0ZUVkMjU1MTlLZXlQYWlyLCBlbmNvZGVCYXNlNjQgYXMgZW5jb2RlQmFzZTY0MiB9IGZyb20gXCJAaWRlbnRpdHktY29ubmVjdC9jcnlwdG9cIjtcblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIERFRkFVTFRfRlJPTlRFTkRfVVJMID0gXCJodHRwczovL2FwdG9zY29ubmVjdC5hcHBcIjtcblxuLy8gc3JjL2NvbnZlcnNpb24udHNcbmltcG9ydCB7XG4gIEFjY291bnRBZGRyZXNzLFxuICBnZW5lcmF0ZVRyYW5zYWN0aW9uUGF5bG9hZCxcbiAgZ2VuZXJhdGVUcmFuc2FjdGlvblBheWxvYWRXaXRoQUJJXG59IGZyb20gXCJAYXB0b3MtbGFicy90cy1zZGtcIjtcbmZ1bmN0aW9uIGNvbnZlcnRUb1NlcmlhbGl6YWJsZUFyZ3VtZW50KGFyZ3VtZW50KSB7XG4gIGlmIChhcmd1bWVudCA9PT0gdm9pZCAwIHx8IGFyZ3VtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50O1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGFyZ3VtZW50KSkge1xuICAgIHJldHVybiBhcmd1bWVudC5tYXAoKHN1YkFyZ3VtZW50KSA9PiBjb252ZXJ0VG9TZXJpYWxpemFibGVBcmd1bWVudChzdWJBcmd1bWVudCkpO1xuICB9XG4gIGlmICh0eXBlb2YgYXJndW1lbnQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGFyZ3VtZW50ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBhcmd1bWVudCA9PT0gXCJib29sZWFuXCIgfHwgYXJndW1lbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYXJndW1lbnQgPT09IFwiYmlnaW50XCIpIHtcbiAgICByZXR1cm4gYXJndW1lbnQudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoYXJndW1lbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShhcmd1bWVudCk7XG4gIH1cbiAgaWYgKFwidmFsdWVzXCIgaW4gYXJndW1lbnQpIHtcbiAgICByZXR1cm4gYXJndW1lbnQudmFsdWVzLm1hcCgoc3ViQXJndW1lbnQpID0+IGNvbnZlcnRUb1NlcmlhbGl6YWJsZUFyZ3VtZW50KHN1YkFyZ3VtZW50KSk7XG4gIH1cbiAgaWYgKFwiZGF0YVwiIGluIGFyZ3VtZW50KSB7XG4gICAgcmV0dXJuIEFjY291bnRBZGRyZXNzLmZyb20oYXJndW1lbnQuZGF0YSkudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAoYXJndW1lbnQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmd1bWVudC52YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgYXJndW1lbnQudmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGFyZ3VtZW50LnZhbHVlID09PSBcImJvb2xlYW5cIiB8fCBhcmd1bWVudC52YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gYXJndW1lbnQudmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcmd1bWVudC52YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgIHJldHVybiBhcmd1bWVudC52YWx1ZS50b1N0cmluZygpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgYXJndW1lbnRcIik7XG59XG5mdW5jdGlvbiBub3JtYWxpemVQYXlsb2FkRm9ySUMocGF5bG9hZCwgYXB0b3NDb25maWcpIHtcbiAgaWYgKFwiYmNzVG9CeXRlc1wiIGluIHBheWxvYWQpIHtcbiAgICByZXR1cm4gcGF5bG9hZDtcbiAgfVxuICBpZiAoXCJieXRlY29kZVwiIGluIHBheWxvYWQpIHtcbiAgICByZXR1cm4gZ2VuZXJhdGVUcmFuc2FjdGlvblBheWxvYWQocGF5bG9hZCk7XG4gIH1cbiAgaWYgKGFwdG9zQ29uZmlnKSB7XG4gICAgcmV0dXJuIHBheWxvYWQuYWJpICE9PSB2b2lkIDAgPyBnZW5lcmF0ZVRyYW5zYWN0aW9uUGF5bG9hZFdpdGhBQkkoeyAuLi5wYXlsb2FkLCBhYmk6IHBheWxvYWQuYWJpIH0pIDogZ2VuZXJhdGVUcmFuc2FjdGlvblBheWxvYWQoeyBhcHRvc0NvbmZpZywgLi4ucGF5bG9hZCB9KTtcbiAgfVxuICBjb25zdCBlbnRyeUZ1bmN0aW9uUGF5bG9hZCA9IHtcbiAgICBhcmd1bWVudHM6IHBheWxvYWQuZnVuY3Rpb25Bcmd1bWVudHMubWFwKGNvbnZlcnRUb1NlcmlhbGl6YWJsZUFyZ3VtZW50KSxcbiAgICBmdW5jdGlvbjogcGF5bG9hZC5mdW5jdGlvbixcbiAgICB0eXBlOiBcImVudHJ5X2Z1bmN0aW9uX3BheWxvYWRcIixcbiAgICB0eXBlX2FyZ3VtZW50czogKHBheWxvYWQudHlwZUFyZ3VtZW50cyA/PyBbXSkubWFwKCh0YSkgPT4gdGEudG9TdHJpbmcoKSlcbiAgfTtcbiAgcmV0dXJuIFwibXVsdGlzaWdBZGRyZXNzXCIgaW4gcGF5bG9hZCA/IHtcbiAgICBtdWx0aXNpZ19hZGRyZXNzOiBBY2NvdW50QWRkcmVzcy5mcm9tKHBheWxvYWQubXVsdGlzaWdBZGRyZXNzKS50b1N0cmluZygpLFxuICAgIHRyYW5zYWN0aW9uX3BheWxvYWQ6IGVudHJ5RnVuY3Rpb25QYXlsb2FkLFxuICAgIHR5cGU6IFwibXVsdGlzaWdfcGF5bG9hZFwiXG4gIH0gOiBlbnRyeUZ1bmN0aW9uUGF5bG9hZDtcbn1cblxuLy8gc3JjL1BhaXJpbmdDbGllbnQudHNcbmltcG9ydCB7IEFjY291bnRBZGRyZXNzIGFzIEFjY291bnRBZGRyZXNzMiB9IGZyb20gXCJAYXB0b3MtbGFicy90cy1zZGtcIjtcbmltcG9ydCB7XG4gIE5ldHdvcmtOYW1lLFxuICBTaWduaW5nUmVxdWVzdFN0YXR1cyxcbiAgU2lnbmluZ1JlcXVlc3RUeXBlc1xufSBmcm9tIFwiQGlkZW50aXR5LWNvbm5lY3QvYXBpXCI7XG5pbXBvcnQge1xuICBkZWNvZGVCYXNlNjQsXG4gIGRlY3J5cHRFbnZlbG9wZSxcbiAgZGVzZXJpYWxpemVFZDI1NTE5UHVibGljS2V5QjY0LFxuICBkZXNlcmlhbGl6ZVB1YmxpY0tleUI2NCxcbiAgZW5jb2RlQmFzZTY0LFxuICBlbmNyeXB0QW5kU2lnbkVudmVsb3BlLFxuICBLZXlUeXBlcyxcbiAgdG9LZXlcbn0gZnJvbSBcIkBpZGVudGl0eS1jb25uZWN0L2NyeXB0b1wiO1xuaW1wb3J0IHtcbiAgZGVzZXJpYWxpemVTaWduVHJhbnNhY3Rpb25SZXNwb25zZUFyZ3MsXG4gIHNlcmlhbGl6ZVNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvblJlcXVlc3RBcmdzLFxuICBzZXJpYWxpemVTaWduVHJhbnNhY3Rpb25SZXF1ZXN0QXJnc1xufSBmcm9tIFwiQGlkZW50aXR5LWNvbm5lY3Qvd2FsbGV0LWFwaVwiO1xuaW1wb3J0IGF4aW9zLCB7IEF4aW9zRXJyb3IsIGlzQXhpb3NFcnJvciB9IGZyb20gXCJheGlvc1wiO1xuXG4vLyBzcmMvZXJyb3JzLnRzXG52YXIgU2lnbmF0dXJlUmVxdWVzdEVycm9yID0gY2xhc3MgX1NpZ25hdHVyZVJlcXVlc3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzKSB7XG4gICAgc3VwZXIoc3RhdHVzKTtcbiAgICB0aGlzLm5hbWUgPSBcIlNpZ25hdHVyZVJlcXVlc3RFcnJvclwiO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfU2lnbmF0dXJlUmVxdWVzdEVycm9yLnByb3RvdHlwZSk7XG4gIH1cbn07XG52YXIgVW5leHBlY3RlZFNpZ25hdHVyZVJlc3BvbnNlRXJyb3IgPSBjbGFzcyBfVW5leHBlY3RlZFNpZ25hdHVyZVJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1pc3NpbmdGaWVsZHMpIHtcbiAgICBjb25zdCBtZXNzYWdlID0gYE1pc3NpbmcgdGhlIGZvbGxvd2luZyBmaWVsZHM6ICR7bWlzc2luZ0ZpZWxkcy5qb2luKFwiLCBcIil9YDtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIlVuZXhwZWN0ZWRTaWduYXR1cmVSZXNwb25zZUVycm9yXCI7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIF9VbmV4cGVjdGVkU2lnbmF0dXJlUmVzcG9uc2VFcnJvci5wcm90b3R5cGUpO1xuICB9XG59O1xudmFyIFBhaXJpbmdFeHBpcmVkRXJyb3IgPSBjbGFzcyBfUGFpcmluZ0V4cGlyZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWUgPSBcIlBhaXJpbmdFeHBpcmVkRXJyb3JcIjtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgX1BhaXJpbmdFeHBpcmVkRXJyb3IucHJvdG90eXBlKTtcbiAgfVxufTtcbnZhciBVbnJlZ2lzdGVyZWREYXBwRXJyb3IgPSBjbGFzcyBfVW5yZWdpc3RlcmVkRGFwcEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkRhcHAgSUQgaXMgaW52YWxpZCBvciBub3QgYXNzb2NpYXRlZCB3aXRoIGEgcmVnaXN0ZXJlZCBEYXBwLlwiKTtcbiAgICB0aGlzLm5hbWUgPSBcIlVucmVnaXN0ZXJlZERhcHBFcnJvclwiO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBfVW5yZWdpc3RlcmVkRGFwcEVycm9yLnByb3RvdHlwZSk7XG4gIH1cbn07XG5cbi8vIHNyYy9zdGF0ZS50c1xudmFyIERBUFBfUEFJUklOR1NfV0lORE9XX1NUT1JBR0VfS0VZID0gXCJpY0RhcHBQYWlyaW5nc1wiO1xudmFyIHdpbmRvd1N0YXRlQWNjZXNzb3JzID0ge1xuICBhc3luYyBnZXQoYWRkcmVzcykge1xuICAgIGNvbnN0IHBhaXJpbmdzID0gYXdhaXQgdGhpcy5nZXRBbGwoKTtcbiAgICByZXR1cm4gcGFpcmluZ3NbYWRkcmVzc107XG4gIH0sXG4gIGFzeW5jIGdldEFsbCgpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKERBUFBfUEFJUklOR1NfV0lORE9XX1NUT1JBR0VfS0VZKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZCA/IEpTT04ucGFyc2Uoc2VyaWFsaXplZCkgOiB7fTtcbiAgfSxcbiAgYXN5bmMgdXBkYXRlKGFkZHJlc3MsIHBhaXJpbmcpIHtcbiAgICBjb25zdCBwYWlyaW5ncyA9IGF3YWl0IHRoaXMuZ2V0QWxsKCk7XG4gICAgaWYgKHBhaXJpbmcgPT09IHZvaWQgMCkge1xuICAgICAgZGVsZXRlIHBhaXJpbmdzW2FkZHJlc3NdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYWlyaW5nc1thZGRyZXNzXSA9IHBhaXJpbmc7XG4gICAgfVxuICAgIGNvbnN0IG5ld1NlcmlhbGl6ZWQgPSBKU09OLnN0cmluZ2lmeShwYWlyaW5ncyk7XG4gICAgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKERBUFBfUEFJUklOR1NfV0lORE9XX1NUT1JBR0VfS0VZLCBuZXdTZXJpYWxpemVkKTtcbiAgfVxufTtcblxuLy8gc3JjL3V0aWxzLnRzXG52YXIgU0lHTl9NRVNTQUdFX1JFU1BPTlNFX1JFUVVJUkVEX0ZJRUxEUyA9IFtcbiAgXCJhZGRyZXNzXCIsXG4gIFwiYXBwbGljYXRpb25cIixcbiAgXCJjaGFpbklkXCIsXG4gIFwiZnVsbE1lc3NhZ2VcIixcbiAgXCJtZXNzYWdlXCIsXG4gIFwibm9uY2VcIixcbiAgXCJwcmVmaXhcIixcbiAgXCJzaWduYXR1cmVcIlxuXTtcbmZ1bmN0aW9uIHZhbGlkYXRlU2lnbk1lc3NhZ2VSZXNwb25zZShyZXNwb25zZSkge1xuICBjb25zdCBwcm92aWRlZEZpZWxkcyA9IG5ldyBTZXQoT2JqZWN0LmtleXMocmVzcG9uc2UpKTtcbiAgY29uc3QgbWlzc2luZ0ZpZWxkcyA9IFNJR05fTUVTU0FHRV9SRVNQT05TRV9SRVFVSVJFRF9GSUVMRFMuZmlsdGVyKChmaWVsZCkgPT4gIXByb3ZpZGVkRmllbGRzLmhhcyhmaWVsZCkpO1xuICBpZiAobWlzc2luZ0ZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRTaWduYXR1cmVSZXNwb25zZUVycm9yKG1pc3NpbmdGaWVsZHMpO1xuICB9XG59XG52YXIgU0lHTl9BTkRfU1VCTUlUX1RSQU5TQUNUSU9OX1JFU1BPTlNFX1JFUVVJUkVEX0ZJRUxEUyA9IFtcImhhc2hcIl07XG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvblJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIGNvbnN0IHByb3ZpZGVkRmllbGRzID0gbmV3IFNldChPYmplY3Qua2V5cyhyZXNwb25zZSkpO1xuICBjb25zdCBtaXNzaW5nRmllbGRzID0gU0lHTl9BTkRfU1VCTUlUX1RSQU5TQUNUSU9OX1JFU1BPTlNFX1JFUVVJUkVEX0ZJRUxEUy5maWx0ZXIoXG4gICAgKGZpZWxkKSA9PiAhcHJvdmlkZWRGaWVsZHMuaGFzKGZpZWxkKVxuICApO1xuICBpZiAobWlzc2luZ0ZpZWxkcy5sZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRTaWduYXR1cmVSZXNwb25zZUVycm9yKG1pc3NpbmdGaWVsZHMpO1xuICB9XG59XG5cbi8vIHNyYy9QYWlyaW5nQ2xpZW50LnRzXG52YXIgQVBJX1ZFUlNJT04gPSBcIjAuMi4wXCI7XG52YXIgU0lHTklOR19SRVFVRVNUX1BPTExJTkdfSU5URVJWQUwgPSAyNTAwO1xudmFyIFNFUVVFTkNFX05VTUJFUl9NSVNNQVRDSF9QQVRURVJOID0gL15TZXF1ZW5jZSBudW1iZXIgbWlzbWF0Y2gsIGV4cGVjdGVkICg/OlxcUysgdG8gYmUgKT8oXFxkKykvO1xuYXN5bmMgZnVuY3Rpb24gd2FpdEZvcihtaWxsaXNlY29uZHMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCBtaWxsaXNlY29uZHMpO1xuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhSZXRyaWVzKHJlcXVlc3RGbiwgb25FcnJvciwgcmV0cmllcyA9IDEpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXRyaWVzOyBpICs9IDEpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHJlcXVlc3RGbigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgb25FcnJvcihlcnIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVxdWVzdEZuKCk7XG59XG52YXIgQUNQYWlyaW5nQ2xpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYWNjZXNzb3JzID0gd2luZG93U3RhdGVBY2Nlc3NvcnMsXG4gICAgYXhpb3NDb25maWcsXG4gICAgZGVmYXVsdE5ldHdvcmtOYW1lID0gTmV0d29ya05hbWUuTUFJTk5FVFxuICB9ID0ge30pIHtcbiAgICAvLyBlbmRyZWdpb25cbiAgICB0aGlzLm9uRGlzY29ubmVjdExpc3RlbmVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5hY2Nlc3NvcnMgPSBhY2Nlc3NvcnM7XG4gICAgdGhpcy5kZWZhdWx0TmV0d29ya05hbWUgPSBkZWZhdWx0TmV0d29ya05hbWU7XG4gICAgdGhpcy5heGlvc0luc3RhbmNlID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgIGJhc2VVUkw6IERFRkFVTFRfRlJPTlRFTkRfVVJMLFxuICAgICAgLi4uYXhpb3NDb25maWdcbiAgICB9KTtcbiAgICBjb25zdCBpc0NsaWVudFNpZGVSZW5kZXJpbmcgPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xuICAgIHRoaXMuaW5pdFByb21pc2UgPSBpc0NsaWVudFNpZGVSZW5kZXJpbmcgPyB0aGlzLnN5bmNGaXJzdFBhaXJpbmcoKSA6IHZvaWQgMDtcbiAgfVxuICBhc3luYyBnZXRQYWlyaW5nKGlkKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2UuZ2V0KGB2MS9wYWlyaW5nLyR7aWR9L2ApO1xuICAgIHJldHVybiByZXNwb25zZS5kYXRhLmRhdGEucGFpcmluZztcbiAgfVxuICBhc3luYyBzeW5jRmlyc3RQYWlyaW5nKCkge1xuICAgIGNvbnN0IHBhaXJpbmdzID0gYXdhaXQgdGhpcy5hY2Nlc3NvcnMuZ2V0QWxsKCk7XG4gICAgY29uc3QgZmlyc3RQYWlyaW5nID0gT2JqZWN0LnZhbHVlcyhwYWlyaW5ncylbMF07XG4gICAgaWYgKGZpcnN0UGFpcmluZyA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhcHBTcGVjaWZpY1dhbGxldCwgbWF4RGFwcFNlcXVlbmNlTnVtYmVyIH0gPSBhd2FpdCB0aGlzLmdldFBhaXJpbmcoZmlyc3RQYWlyaW5nLnBhaXJpbmdJZCk7XG4gICAgICBhd2FpdCB0aGlzLmFjY2Vzc29ycy51cGRhdGUoZmlyc3RQYWlyaW5nLmFjY291bnRBZGRyZXNzLCB7XG4gICAgICAgIC4uLmZpcnN0UGFpcmluZyxcbiAgICAgICAgY3VyclNlcXVlbmNlTnVtYmVyOiBtYXhEYXBwU2VxdWVuY2VOdW1iZXIsXG4gICAgICAgIGRhcHBXYWxsZXRJZDogZGFwcFNwZWNpZmljV2FsbGV0Py5pZFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBhd2FpdCB0aGlzLmFjY2Vzc29ycy51cGRhdGUoZmlyc3RQYWlyaW5nLmFjY291bnRBZGRyZXNzLCB2b2lkIDApO1xuICAgIH1cbiAgfVxuICBhc3luYyBjcmVhdGVTaWduaW5nUmVxdWVzdChwYWlyaW5nLCB0eXBlLCBuZXR3b3JrTmFtZSwgcmVxdWVzdEJvZHkpIHtcbiAgICBjb25zdCBkYXBwRWQyNTUxOVNlY3JldEtleSA9IGRlY29kZUJhc2U2NChwYWlyaW5nLmRhcHBFZDI1NTE5U2VjcmV0S2V5QjY0KTtcbiAgICBjb25zdCBkYXBwRWQyNTUxOVB1YmxpY0tleSA9IGRlY29kZUJhc2U2NChwYWlyaW5nLmRhcHBFZDI1NTE5UHVibGljS2V5QjY0KTtcbiAgICBjb25zdCBhY2NvdW50VHJhbnNwb3J0RWQyNTUxOVB1YmxpY0tleSA9IGRlY29kZUJhc2U2NChwYWlyaW5nLmFjY291bnRUcmFuc3BvcnRFZDI1NTE5UHVibGljS2V5QjY0KTtcbiAgICBsZXQgc2VxdWVuY2VOdW1iZXIgPSBwYWlyaW5nLmN1cnJTZXF1ZW5jZU51bWJlciArIDE7XG4gICAgcmV0dXJuIHdpdGhSZXRyaWVzKFxuICAgICAgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0RW52ZWxvcGUgPSBhd2FpdCBlbmNyeXB0QW5kU2lnbkVudmVsb3BlKFxuICAgICAgICAgIHRvS2V5KGRhcHBFZDI1NTE5U2VjcmV0S2V5LCBLZXlUeXBlcy5FZDI1NTE5U2VjcmV0S2V5KSxcbiAgICAgICAgICB0b0tleShkYXBwRWQyNTUxOVB1YmxpY0tleSwgS2V5VHlwZXMuRWQyNTUxOVB1YmxpY0tleSksXG4gICAgICAgICAgdG9LZXkoYWNjb3VudFRyYW5zcG9ydEVkMjU1MTlQdWJsaWNLZXksIEtleVR5cGVzLkVkMjU1MTlQdWJsaWNLZXkpLFxuICAgICAgICAgIHNlcXVlbmNlTnVtYmVyLFxuICAgICAgICAgIHsgYXBpVmVyc2lvbjogQVBJX1ZFUlNJT04sIG5ldHdvcmtOYW1lLCByZXF1ZXN0VHlwZTogdHlwZSB9LFxuICAgICAgICAgIHJlcXVlc3RCb2R5XG4gICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5heGlvc0luc3RhbmNlLnBvc3QoXG4gICAgICAgICAgYHYxL3BhaXJpbmcvJHtwYWlyaW5nLnBhaXJpbmdJZH0vc2lnbmluZy1yZXF1ZXN0L2AsXG4gICAgICAgICAgcmVxdWVzdEVudmVsb3BlXG4gICAgICAgICk7XG4gICAgICAgIGF3YWl0IHRoaXMuYWNjZXNzb3JzLnVwZGF0ZShwYWlyaW5nLmFjY291bnRBZGRyZXNzLCB7XG4gICAgICAgICAgLi4ucGFpcmluZyxcbiAgICAgICAgICBjdXJyU2VxdWVuY2VOdW1iZXI6IHNlcXVlbmNlTnVtYmVyXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YS5kYXRhLnNpZ25pbmdSZXF1ZXN0O1xuICAgICAgfSxcbiAgICAgIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGlzQXhpb3NFcnJvcihlcnIpKSB7XG4gICAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlO1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkU2VxdWVuY2VOdW1iZXIgPSBlcnJvck1lc3NhZ2U/Lm1hdGNoKFNFUVVFTkNFX05VTUJFUl9NSVNNQVRDSF9QQVRURVJOKT8uWzFdO1xuICAgICAgICAgIGlmIChleHBlY3RlZFNlcXVlbmNlTnVtYmVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyID0gTnVtYmVyKGV4cGVjdGVkU2VxdWVuY2VOdW1iZXIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICBhc3luYyBnZXRTaWduaW5nUmVxdWVzdChpZCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5heGlvc0luc3RhbmNlLmdldChcbiAgICAgIGB2MS9zaWduaW5nLXJlcXVlc3QvJHtpZH0vYCxcbiAgICAgIHtcbiAgICAgICAgdmFsaWRhdGVTdGF0dXM6IChzdGF0dXMpID0+IHN0YXR1cyA9PT0gMjAwIHx8IHN0YXR1cyA9PT0gNDA0XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuZGF0YT8uZGF0YT8uc2lnbmluZ1JlcXVlc3Q7XG4gIH1cbiAgYXN5bmMgZGVsZXRlUGFpcmluZyhwYWlyaW5nSWQsIHNlY3JldEtleSwgcHVibGljS2V5KSB7XG4gICAgY29uc3QgcmVxdWVzdEVudmVsb3BlID0gYXdhaXQgZW5jcnlwdEFuZFNpZ25FbnZlbG9wZShcbiAgICAgIHNlY3JldEtleSxcbiAgICAgIHB1YmxpY0tleSxcbiAgICAgIHB1YmxpY0tleSxcbiAgICAgIDAsXG4gICAgICAvLyBpZ25vcmVkXG4gICAgICB7fSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2UucG9zdChcbiAgICAgIGB2MS9wYWlyaW5nLyR7cGFpcmluZ0lkfS9kZWxldGUvYCxcbiAgICAgIHJlcXVlc3RFbnZlbG9wZSxcbiAgICAgIHsgdmFsaWRhdGVTdGF0dXM6IChzdGF0dXMpID0+IHN0YXR1cyA9PT0gMjA0IHx8IHN0YXR1cyA9PT0gNDA0IH1cbiAgICApO1xuICB9XG4gIGFzeW5jIGNhbmNlbFNpZ25pbmdSZXF1ZXN0KHBhaXJpbmcsIGlkKSB7XG4gICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBwYWlyaW5nLmN1cnJTZXF1ZW5jZU51bWJlcjtcbiAgICBjb25zdCBkYXBwRWQyNTUxOVNlY3JldEtleSA9IGRlY29kZUJhc2U2NChwYWlyaW5nLmRhcHBFZDI1NTE5U2VjcmV0S2V5QjY0KTtcbiAgICBjb25zdCBkYXBwRWQyNTUxOVB1YmxpY0tleSA9IGRlY29kZUJhc2U2NChwYWlyaW5nLmRhcHBFZDI1NTE5UHVibGljS2V5QjY0KTtcbiAgICBjb25zdCBhY2NvdW50VHJhbnNwb3J0RWQyNTUxOVB1YmxpY0tleSA9IGRlY29kZUJhc2U2NChwYWlyaW5nLmFjY291bnRUcmFuc3BvcnRFZDI1NTE5UHVibGljS2V5QjY0KTtcbiAgICBjb25zdCByZXF1ZXN0RW52ZWxvcGUgPSBhd2FpdCBlbmNyeXB0QW5kU2lnbkVudmVsb3BlKFxuICAgICAgdG9LZXkoZGFwcEVkMjU1MTlTZWNyZXRLZXksIEtleVR5cGVzLkVkMjU1MTlTZWNyZXRLZXkpLFxuICAgICAgdG9LZXkoZGFwcEVkMjU1MTlQdWJsaWNLZXksIEtleVR5cGVzLkVkMjU1MTlQdWJsaWNLZXkpLFxuICAgICAgdG9LZXkoYWNjb3VudFRyYW5zcG9ydEVkMjU1MTlQdWJsaWNLZXksIEtleVR5cGVzLkVkMjU1MTlQdWJsaWNLZXkpLFxuICAgICAgc2VxdWVuY2VOdW1iZXIgKyAxLFxuICAgICAge30sXG4gICAgICB7fVxuICAgICk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2UucGF0Y2goXG4gICAgICBgdjEvc2lnbmluZy1yZXF1ZXN0LyR7aWR9L2NhbmNlbC9gLFxuICAgICAgcmVxdWVzdEVudmVsb3BlXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLmFjY2Vzc29ycy51cGRhdGUocGFpcmluZy5hY2NvdW50QWRkcmVzcywge1xuICAgICAgLi4ucGFpcmluZyxcbiAgICAgIGN1cnJTZXF1ZW5jZU51bWJlcjogc2VxdWVuY2VOdW1iZXIgKyAxXG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuZGF0YS5zaWduaW5nUmVxdWVzdDtcbiAgfVxuICBhc3luYyBzaWduUmVxdWVzdChhZGRyZXNzLCB0eXBlLCByZXF1ZXN0Qm9keSwgeyBjYW5jZWxUb2tlbiwgbmV0d29ya05hbWUgfSA9IHt9KSB7XG4gICAgYXdhaXQgdGhpcy5pbml0UHJvbWlzZTtcbiAgICBjb25zdCBwYWlyaW5nID0gYXdhaXQgdGhpcy5hY2Nlc3NvcnMuZ2V0KGFkZHJlc3MpO1xuICAgIGlmIChwYWlyaW5nID09PSB2b2lkIDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXF1ZXN0ZWQgYWNjb3VudCBpcyBub3QgcGFpcmVkXCIpO1xuICAgIH1cbiAgICBsZXQgc2lnbmluZ1JlcXVlc3Q7XG4gICAgdHJ5IHtcbiAgICAgIHNpZ25pbmdSZXF1ZXN0ID0gYXdhaXQgdGhpcy5jcmVhdGVTaWduaW5nUmVxdWVzdChcbiAgICAgICAgcGFpcmluZyxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbmV0d29ya05hbWUgfHwgdGhpcy5kZWZhdWx0TmV0d29ya05hbWUsXG4gICAgICAgIHJlcXVlc3RCb2R5XG4gICAgICApO1xuICAgICAgd2hpbGUgKHNpZ25pbmdSZXF1ZXN0LnN0YXR1cyA9PT0gXCJQRU5ESU5HXCIpIHtcbiAgICAgICAgYXdhaXQgd2FpdEZvcihTSUdOSU5HX1JFUVVFU1RfUE9MTElOR19JTlRFUlZBTCk7XG4gICAgICAgIGlmIChjYW5jZWxUb2tlbj8uY2FuY2VsbGVkKSB7XG4gICAgICAgICAgc2lnbmluZ1JlcXVlc3Quc3RhdHVzID0gU2lnbmluZ1JlcXVlc3RTdGF0dXMuQ0FOQ0VMTEVEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNpZ25pbmdSZXF1ZXN0ID0gYXdhaXQgdGhpcy5nZXRTaWduaW5nUmVxdWVzdChzaWduaW5nUmVxdWVzdC5pZCkgPz8gc2lnbmluZ1JlcXVlc3Q7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoaXNBeGlvc0Vycm9yKGVycikgJiYgZXJyLmNvZGUgPT09IFwiNDA0XCIpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5hY2Nlc3NvcnMudXBkYXRlKGFkZHJlc3MsIHZvaWQgMCk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5vbkRpc2Nvbm5lY3RMaXN0ZW5lcnMpIHtcbiAgICAgICAgICBsaXN0ZW5lcihhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgUGFpcmluZ0V4cGlyZWRFcnJvcigpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgICBpZiAoc2lnbmluZ1JlcXVlc3Quc3RhdHVzICE9PSBcIkFQUFJPVkVEXCIpIHtcbiAgICAgIHRocm93IG5ldyBTaWduYXR1cmVSZXF1ZXN0RXJyb3Ioc2lnbmluZ1JlcXVlc3Quc3RhdHVzKTtcbiAgICB9XG4gICAgY29uc3QgZGVjcnlwdGVkID0gZGVjcnlwdEVudmVsb3BlKFxuICAgICAgdG9LZXkoZGVjb2RlQmFzZTY0KHBhaXJpbmcuYWNjb3VudFRyYW5zcG9ydEVkMjU1MTlQdWJsaWNLZXlCNjQpLCBLZXlUeXBlcy5FZDI1NTE5UHVibGljS2V5KSxcbiAgICAgIHRvS2V5KGRlY29kZUJhc2U2NChwYWlyaW5nLmRhcHBFZDI1NTE5U2VjcmV0S2V5QjY0KSwgS2V5VHlwZXMuRWQyNTUxOVNlY3JldEtleSksXG4gICAgICBzaWduaW5nUmVxdWVzdC5yZXNwb25zZUVudmVsb3BlXG4gICAgKTtcbiAgICByZXR1cm4gZGVjcnlwdGVkLnByaXZhdGVNZXNzYWdlO1xuICB9XG4gIC8vIHJlZ2lvbiBQdWJsaWMgQVBJXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhIGNvbm5lY3Rpb24gdG8gYW4gYWNjb3VudCAoaW50ZXJuYWxseSBrbm93biBhcyBwYWlyaW5nKS5cbiAgICogQHJldHVybnMgZWl0aGVyIHRoZSBhZGRyZXNzIG9mIHRoZSBjb25uZWN0ZWQgYWNjb3VudCwgb3IgdW5kZWZpbmVkIGlmIHRoZVxuICAgKiBjb25uZWN0aW9uIHdhcyBjYW5jZWxsZWQuXG4gICAqL1xuICBhc3luYyBhZGRQYWlyaW5nKHsgcHVibGljS2V5LCBzZWNyZXRLZXkgfSwgZmluYWxpemVkUGFpcmluZykge1xuICAgIGF3YWl0IHRoaXMuYWNjZXNzb3JzLnVwZGF0ZShmaW5hbGl6ZWRQYWlyaW5nLmFjY291bnQuYWNjb3VudEFkZHJlc3MsIHtcbiAgICAgIGFjY291bnRBZGRyZXNzOiBmaW5hbGl6ZWRQYWlyaW5nLmFjY291bnQuYWNjb3VudEFkZHJlc3MsXG4gICAgICBhY2NvdW50QWxpYXM6IGZpbmFsaXplZFBhaXJpbmcuYWNjb3VudC51c2VyU3VibWl0dGVkQWxpYXMgPz8gdm9pZCAwLFxuICAgICAgYWNjb3VudFB1YmxpY0tleUI2NDogZmluYWxpemVkUGFpcmluZy5hY2NvdW50LnB1YmxpY0tleUI2NCxcbiAgICAgIGFjY291bnRUcmFuc3BvcnRFZDI1NTE5UHVibGljS2V5QjY0OiBmaW5hbGl6ZWRQYWlyaW5nLmFjY291bnQudHJhbnNwb3J0RWQyNTUxOVB1YmxpY0tleUI2NCxcbiAgICAgIGN1cnJTZXF1ZW5jZU51bWJlcjogZmluYWxpemVkUGFpcmluZy5tYXhEYXBwU2VxdWVuY2VOdW1iZXIsXG4gICAgICBkYXBwRWQyNTUxOVB1YmxpY0tleUI2NDogZW5jb2RlQmFzZTY0KHB1YmxpY0tleS5rZXkpLFxuICAgICAgZGFwcEVkMjU1MTlTZWNyZXRLZXlCNjQ6IGVuY29kZUJhc2U2NChzZWNyZXRLZXkua2V5KSxcbiAgICAgIGRhcHBXYWxsZXRJZDogZmluYWxpemVkUGFpcmluZy5kYXBwU3BlY2lmaWNXYWxsZXRJZCxcbiAgICAgIHBhaXJpbmdJZDogZmluYWxpemVkUGFpcmluZy5pZFxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGRpc2Nvbm5lY3QoYWRkcmVzcykge1xuICAgIGNvbnN0IHBhaXJpbmcgPSBhd2FpdCB0aGlzLmFjY2Vzc29ycy5nZXQoYWRkcmVzcyk7XG4gICAgaWYgKHBhaXJpbmcgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHNwZWNpZmllZCBhY2NvdW50IGlzIG5vdCBwYWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGRhcHBFZDI1NTE5U2VjcmV0S2V5ID0gZGVjb2RlQmFzZTY0KHBhaXJpbmcuZGFwcEVkMjU1MTlTZWNyZXRLZXlCNjQpO1xuICAgIGNvbnN0IGRhcHBFZDI1NTE5UHVibGljS2V5ID0gZGVjb2RlQmFzZTY0KHBhaXJpbmcuZGFwcEVkMjU1MTlQdWJsaWNLZXlCNjQpO1xuICAgIGF3YWl0IHRoaXMuZGVsZXRlUGFpcmluZyhcbiAgICAgIHBhaXJpbmcucGFpcmluZ0lkLFxuICAgICAgdG9LZXkoZGFwcEVkMjU1MTlTZWNyZXRLZXksIEtleVR5cGVzLkVkMjU1MTlTZWNyZXRLZXkpLFxuICAgICAgdG9LZXkoZGFwcEVkMjU1MTlQdWJsaWNLZXksIEtleVR5cGVzLkVkMjU1MTlQdWJsaWNLZXkpXG4gICAgKTtcbiAgICBhd2FpdCB0aGlzLmFjY2Vzc29ycy51cGRhdGUoYWRkcmVzcywgdm9pZCAwKTtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMub25EaXNjb25uZWN0TGlzdGVuZXJzKSB7XG4gICAgICBsaXN0ZW5lcihhZGRyZXNzKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UoYWRkcmVzcywgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5zaWduUmVxdWVzdChcbiAgICAgIGFkZHJlc3MsXG4gICAgICBTaWduaW5nUmVxdWVzdFR5cGVzLlNJR05fTUVTU0FHRSxcbiAgICAgIGFyZ3MsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgICB2YWxpZGF0ZVNpZ25NZXNzYWdlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24oYWRkcmVzcywgYXJncywgb3B0aW9ucykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXF1ZXN0QXJncyA9IHNlcmlhbGl6ZVNpZ25UcmFuc2FjdGlvblJlcXVlc3RBcmdzKGFyZ3MpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXNwb25zZUFyZ3MgPSBhd2FpdCB0aGlzLnNpZ25SZXF1ZXN0KGFkZHJlc3MsIFNpZ25pbmdSZXF1ZXN0VHlwZXMuU0lHTl9UUkFOU0FDVElPTiwgc2VyaWFsaXplZFJlcXVlc3RBcmdzLCBvcHRpb25zKTtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVTaWduVHJhbnNhY3Rpb25SZXNwb25zZUFyZ3Moc2VyaWFsaXplZFJlc3BvbnNlQXJncyk7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG4gIGFzeW5jIHNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvbihhZGRyZXNzLCBhcmdzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFJlcXVlc3RBcmdzID0gc2VyaWFsaXplU2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uUmVxdWVzdEFyZ3MoYXJncyk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlQXJncyA9IGF3YWl0IHRoaXMuc2lnblJlcXVlc3QoYWRkcmVzcywgU2lnbmluZ1JlcXVlc3RUeXBlcy5TSUdOX0FORF9TVUJNSVRfVFJBTlNBQ1RJT04sIHNlcmlhbGl6ZWRSZXF1ZXN0QXJncywgb3B0aW9ucyk7XG4gICAgICB2YWxpZGF0ZVNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvblJlc3BvbnNlKHJlc3BvbnNlQXJncyk7XG4gICAgICByZXR1cm4gcmVzcG9uc2VBcmdzO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgQXhpb3NFcnJvciAmJiBlLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlLnJlc3BvbnNlPy5kYXRhPy5tZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICB9XG4gIGFzeW5jIGdldENvbm5lY3RlZEFjY291bnRzKCkge1xuICAgIGF3YWl0IHRoaXMuaW5pdFByb21pc2U7XG4gICAgY29uc3QgcGFpcmluZ3MgPSBhd2FpdCB0aGlzLmFjY2Vzc29ycy5nZXRBbGwoKTtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhwYWlyaW5ncykubWFwKFxuICAgICAgKHsgYWNjb3VudEFkZHJlc3MsIGFjY291bnRFZDI1NTE5UHVibGljS2V5QjY0LCBhY2NvdW50UHVibGljS2V5QjY0IH0pID0+ICh7XG4gICAgICAgIGFkZHJlc3M6IEFjY291bnRBZGRyZXNzMi5mcm9tKGFjY291bnRBZGRyZXNzKSxcbiAgICAgICAgcHVibGljS2V5OiBhY2NvdW50UHVibGljS2V5QjY0ICE9PSB2b2lkIDAgPyBkZXNlcmlhbGl6ZVB1YmxpY0tleUI2NChhY2NvdW50UHVibGljS2V5QjY0KSA6IGRlc2VyaWFsaXplRWQyNTUxOVB1YmxpY0tleUI2NChhY2NvdW50RWQyNTUxOVB1YmxpY0tleUI2NClcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBvbkRpc2Nvbm5lY3QobGlzdGVuZXIpIHtcbiAgICB0aGlzLm9uRGlzY29ubmVjdExpc3RlbmVycy5hZGQobGlzdGVuZXIpO1xuICAgIHJldHVybiAoKSA9PiB0aGlzLm9uRGlzY29ubmVjdExpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICB9XG59O1xuXG4vLyBzcmMvQUNEYXBwQ2xpZW50LnRzXG52YXIgQUNEYXBwQ2xpZW50ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFja2VuZEJhc2VVUkwsXG4gICAgZGFwcElkLFxuICAgIGRhcHBJbWFnZVVSSSxcbiAgICBkYXBwTmFtZSxcbiAgICBkZWZhdWx0TmV0d29ya05hbWUgPSBOZXR3b3JrTmFtZTIuTUFJTk5FVCxcbiAgICBmcm9udGVuZEJhc2VVUkwgPSBERUZBVUxUX0ZST05URU5EX1VSTCxcbiAgICBwcm92aWRlciA9IFwiZ29vZ2xlXCJcbiAgfSA9IHt9KSB7XG4gICAgdGhpcy5kZWZhdWx0TmV0d29ya05hbWUgPSBkZWZhdWx0TmV0d29ya05hbWU7XG4gICAgdGhpcy5kYXBwSW5mbyA9IHtcbiAgICAgIGRvbWFpbjogd2luZG93LmxvY2F0aW9uLm9yaWdpbixcbiAgICAgIGltYWdlVVJJOiBkYXBwSW1hZ2VVUkksXG4gICAgICBuYW1lOiBkYXBwTmFtZSA/PyBkb2N1bWVudC50aXRsZVxuICAgIH07XG4gICAgdGhpcy50cmFuc3BvcnQgPSBuZXcgV2ViV2FsbGV0VHJhbnNwb3J0KGZyb250ZW5kQmFzZVVSTCwgcHJvdmlkZXIpO1xuICAgIHRoaXMuZGFwcElkID0gZGFwcElkO1xuICAgIHRoaXMucGFpcmluZ0NsaWVudCA9IG5ldyBBQ1BhaXJpbmdDbGllbnQoe1xuICAgICAgYXhpb3NDb25maWc6IHtcbiAgICAgICAgYmFzZVVSTDogYmFja2VuZEJhc2VVUkwgPz8gZnJvbnRlbmRCYXNlVVJMXG4gICAgICB9LFxuICAgICAgZGVmYXVsdE5ldHdvcmtOYW1lXG4gICAgfSk7XG4gIH1cbiAgLy8gcmVnaW9uIFB1YmxpYyBBUElcbiAgYXN5bmMgZ2V0S2V5bGVzc0FjY291bnRzKCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXF1ZXN0ID0gR2V0Q29ubmVjdGVkQWNjb3VudHNSZXF1ZXN0LnNlcmlhbGl6ZSh0aGlzLmRhcHBJbmZvKTtcbiAgICBjb25zdCBzZXJpYWxpemVkUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZW5kUmVxdWVzdChzZXJpYWxpemVkUmVxdWVzdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBHZXRDb25uZWN0ZWRBY2NvdW50c1Jlc3BvbnNlLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRSZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmFyZ3M7XG4gIH1cbiAgYXN5bmMgZ2V0SWNBY2NvdW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5wYWlyaW5nQ2xpZW50LmdldENvbm5lY3RlZEFjY291bnRzKCkgPz8gW107XG4gIH1cbiAgYXN5bmMgaXNJY0FjY291bnQoYWRkcmVzcykge1xuICAgIGNvbnN0IGljQWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEljQWNjb3VudHMoKTtcbiAgICByZXR1cm4gaWNBY2NvdW50cy5maW5kKChhY2NvdW50KSA9PiBhY2NvdW50LmFkZHJlc3MuZXF1YWxzKEFjY291bnRBZGRyZXNzMy5mcm9tKGFkZHJlc3MpKSkgIT09IHZvaWQgMDtcbiAgfVxuICBhc3luYyBnZXRDb25uZWN0ZWRBY2NvdW50cygpIHtcbiAgICBjb25zdCBrZXlsZXNzQWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEtleWxlc3NBY2NvdW50cygpO1xuICAgIGNvbnN0IGljQWNjb3VudHMgPSBhd2FpdCB0aGlzLmdldEljQWNjb3VudHMoKTtcbiAgICByZXR1cm4gWy4uLmtleWxlc3NBY2NvdW50cywgLi4uaWNBY2NvdW50c107XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdChhZGRyZXNzKSB7XG4gICAgaWYgKGF3YWl0IHRoaXMuaXNJY0FjY291bnQoYWRkcmVzcykpIHtcbiAgICAgIGNvbnN0IHN0cmluZ0FkZHJlc3MgPSBBY2NvdW50QWRkcmVzczMuZnJvbShhZGRyZXNzKS50b1N0cmluZygpO1xuICAgICAgYXdhaXQgdGhpcy5wYWlyaW5nQ2xpZW50LmRpc2Nvbm5lY3Qoc3RyaW5nQWRkcmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXF1ZXN0ID0gRGlzY29ubmVjdFJlcXVlc3Quc2VyaWFsaXplKHRoaXMuZGFwcEluZm8pO1xuICAgICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuc2VuZFJlcXVlc3Qoc2VyaWFsaXplZFJlcXVlc3QpO1xuICAgIH1cbiAgfVxuICBhc3luYyBjb25uZWN0KHtcbiAgICBjbGFpbU9wdGlvbnMsXG4gICAgcHJlZmVycmVkV2FsbGV0TmFtZVxuICB9ID0ge30pIHtcbiAgICBjb25zdCBkYXBwS2V5cGFpciA9IGNyZWF0ZUVkMjU1MTlLZXlQYWlyKCk7XG4gICAgY29uc3QgaW5qZWN0ZWRQcmVmZXJyZWRXYWxsZXROYW1lID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5BQ19QUkVGRVJSRURfV0FMTEVUX05BTUUgOiB2b2lkIDA7XG4gICAgY29uc3QgcmVxdWVzdEFyZ3MgPSB7XG4gICAgICBjbGFpbU9wdGlvbnMsXG4gICAgICBkYXBwRWQyNTUxOVB1YmxpY0tleUI2NDogZW5jb2RlQmFzZTY0MihkYXBwS2V5cGFpci5wdWJsaWNLZXkua2V5KSxcbiAgICAgIGRhcHBJZDogdGhpcy5kYXBwSWQsXG4gICAgICBwcmVmZXJyZWRXYWxsZXROYW1lOiBwcmVmZXJyZWRXYWxsZXROYW1lID8/IGluamVjdGVkUHJlZmVycmVkV2FsbGV0TmFtZVxuICAgIH07XG4gICAgY29uc3Qgc2VyaWFsaXplZFJlcXVlc3QgPSBDb25uZWN0UmVxdWVzdC5zZXJpYWxpemUodGhpcy5kYXBwSW5mbywgcmVxdWVzdEFyZ3MpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnNlbmRSZXF1ZXN0KHNlcmlhbGl6ZWRSZXF1ZXN0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IENvbm5lY3RSZXNwb25zZS5kZXNlcmlhbGl6ZShzZXJpYWxpemVkUmVzcG9uc2UpO1xuICAgIGlmIChyZXNwb25zZS5hcmdzLnN0YXR1cyA9PT0gXCJhcHByb3ZlZFwiKSB7XG4gICAgICBjb25zdCB7IGFjY291bnQsIHBhaXJpbmcgfSA9IHJlc3BvbnNlLmFyZ3MuYXJncztcbiAgICAgIGlmIChwYWlyaW5nKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucGFpcmluZ0NsaWVudC5hZGRQYWlyaW5nKGRhcHBLZXlwYWlyLCBwYWlyaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYWtlVXNlckFwcHJvdmFsKHsgYWNjb3VudCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3BvbnNlLmFyZ3M7XG4gIH1cbiAgYXN5bmMgc2lnbk1lc3NhZ2UoYXJncykge1xuICAgIGNvbnN0IHsgc2lnbmVyQWRkcmVzcyB9ID0gYXJncztcbiAgICBpZiAoYXdhaXQgdGhpcy5pc0ljQWNjb3VudChzaWduZXJBZGRyZXNzKSkge1xuICAgICAgY29uc3QgeyBjaGFpbklkIH0gPSBhcmdzO1xuICAgICAgY29uc3QgbmV0d29yayA9IGNoYWluSWRUb05ldHdvcmsoY2hhaW5JZCk7XG4gICAgICBsZXQgbWVzc2FnZTtcbiAgICAgIGxldCBub25jZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2UgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXJncy5tZXNzYWdlKTtcbiAgICAgICAgbm9uY2UgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYXJncy5ub25jZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiT25seSBVVEYtOCBlbmNvZGVkIHRleHQgaXMgc3VwcG9ydGVkIHdoZW4gdXNpbmcgSUNcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB7IGZ1bGxNZXNzYWdlLCBzaWduYXR1cmU6IGhleFNpZ25hdHVyZSB9ID0gYXdhaXQgdGhpcy5wYWlyaW5nQ2xpZW50LnNpZ25NZXNzYWdlKFxuICAgICAgICBzaWduZXJBZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgIHtcbiAgICAgICAgICBhZGRyZXNzOiB0cnVlLFxuICAgICAgICAgIGFwcGxpY2F0aW9uOiB0cnVlLFxuICAgICAgICAgIGNoYWluSWQ6IHRydWUsXG4gICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICBub25jZVxuICAgICAgICB9LFxuICAgICAgICB7IG5ldHdvcmtOYW1lOiBuZXR3b3JrIH1cbiAgICAgICk7XG4gICAgICBjb25zdCBzaWduYXR1cmVCeXRlcyA9IEhleC5mcm9tSGV4SW5wdXQoaGV4U2lnbmF0dXJlKS50b1VpbnQ4QXJyYXkoKTtcbiAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25hdHVyZUJ5dGVzLmxlbmd0aCA9PT0gRWQyNTUxOVNpZ25hdHVyZS5MRU5HVEggPyBuZXcgRWQyNTUxOVNpZ25hdHVyZShzaWduYXR1cmVCeXRlcykgOiBBbnlTaWduYXR1cmUuZGVzZXJpYWxpemUobmV3IERlc2VyaWFsaXplcihzaWduYXR1cmVCeXRlcykpO1xuICAgICAgcmV0dXJuIG1ha2VVc2VyQXBwcm92YWwoe1xuICAgICAgICBmdWxsTWVzc2FnZSxcbiAgICAgICAgc2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZFJlcXVlc3QgPSBTaWduTWVzc2FnZVJlcXVlc3Quc2VyaWFsaXplKHRoaXMuZGFwcEluZm8sIGFyZ3MpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnNlbmRSZXF1ZXN0KHNlcmlhbGl6ZWRSZXF1ZXN0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IFNpZ25NZXNzYWdlUmVzcG9uc2UuZGVzZXJpYWxpemUoc2VyaWFsaXplZFJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuYXJncztcbiAgfVxuICBhc3luYyBzaWduVHJhbnNhY3Rpb24oYXJncykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRBcmdzID0gXCJ0cmFuc2FjdGlvblwiIGluIGFyZ3MgPyBTaWduVHJhbnNhY3Rpb25SZXF1ZXN0Lm5vcm1hbGl6ZUFyZ3MoYXJncykgOiBhcmdzO1xuICAgIGNvbnN0IHsgc2lnbmVyQWRkcmVzcyB9ID0gYXJncztcbiAgICBpZiAoYXdhaXQgdGhpcy5pc0ljQWNjb3VudChzaWduZXJBZGRyZXNzKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBleHBpcmF0aW9uU2Vjb25kc0Zyb21Ob3csXG4gICAgICAgIGV4cGlyYXRpb25UaW1lc3RhbXAsXG4gICAgICAgIGZlZVBheWVyLFxuICAgICAgICBnYXNVbml0UHJpY2UsXG4gICAgICAgIG1heEdhc0Ftb3VudCxcbiAgICAgICAgbmV0d29yayxcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgc2Vjb25kYXJ5U2lnbmVycyxcbiAgICAgICAgc2VuZGVyLFxuICAgICAgICBzZXF1ZW5jZU51bWJlclxuICAgICAgfSA9IG5vcm1hbGl6ZWRBcmdzO1xuICAgICAgaWYgKGZlZVBheWVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3BvbnNvcmVkIHRyYW5zYWN0aW9uIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHNlY29uZGFyeVNpZ25lcnMgJiYgc2Vjb25kYXJ5U2lnbmVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpLWFnZW50IHRyYW5zYWN0aW9ucyBub3QgY3VycmVudGx5IHN1cHBvcnRlZFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICghKFwiYmNzVG9CeXRlc1wiIGluIHBheWxvYWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBheWxvYWQgaW5wdXQgZm9ybWF0IGlzIG9ubHkgc3VwcG9ydGVkIHdpdGggS2V5bGVzcyBhY2NvdW50cy5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZUFyZ3MgPSBhd2FpdCB0aGlzLnBhaXJpbmdDbGllbnQuc2lnblRyYW5zYWN0aW9uKFxuICAgICAgICBzaWduZXJBZGRyZXNzLnRvU3RyaW5nKCksXG4gICAgICAgIHtcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBleHBpcmF0aW9uU2Vjb25kc0Zyb21Ob3csXG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZXN0YW1wLFxuICAgICAgICAgICAgZ2FzVW5pdFByaWNlLFxuICAgICAgICAgICAgbWF4R2FzQW1vdW50LFxuICAgICAgICAgICAgc2VuZGVyOiBzZW5kZXI/LmFkZHJlc3MudG9TdHJpbmcoKSxcbiAgICAgICAgICAgIHNlcXVlbmNlTnVtYmVyOiBzZXF1ZW5jZU51bWJlciAhPT0gdm9pZCAwID8gTnVtYmVyKHNlcXVlbmNlTnVtYmVyKSA6IHZvaWQgMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGF5bG9hZFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmV0d29ya05hbWU6IG5ldHdvcmtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICAgIHJldHVybiBtYWtlVXNlckFwcHJvdmFsKHtcbiAgICAgICAgYXV0aGVudGljYXRvcjogcmVzcG9uc2VBcmdzLmFjY291bnRBdXRoZW50aWNhdG9yLFxuICAgICAgICByYXdUcmFuc2FjdGlvbjogcmVzcG9uc2VBcmdzLnJhd1R4blxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXF1ZXN0ID0gU2lnblRyYW5zYWN0aW9uUmVxdWVzdC5zZXJpYWxpemUodGhpcy5kYXBwSW5mbywgbm9ybWFsaXplZEFyZ3MpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnNlbmRSZXF1ZXN0KHNlcmlhbGl6ZWRSZXF1ZXN0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IFNpZ25UcmFuc2FjdGlvblJlc3BvbnNlLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRSZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmFyZ3M7XG4gIH1cbiAgYXN5bmMgc2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uKGFyZ3MpIHtcbiAgICBjb25zdCB7IHNpZ25lckFkZHJlc3MgfSA9IGFyZ3M7XG4gICAgaWYgKGF3YWl0IHRoaXMuaXNJY0FjY291bnQoc2lnbmVyQWRkcmVzcykpIHtcbiAgICAgIGNvbnN0IHsgZXhwaXJhdGlvblRpbWVzdGFtcCwgZmVlUGF5ZXIsIGdhc1VuaXRQcmljZSwgbWF4R2FzQW1vdW50LCBuZXR3b3JrIH0gPSBhcmdzO1xuICAgICAgY29uc3QgYXB0b3NDb25maWcgPSBuZXcgQXB0b3NDb25maWcyKHsgbmV0d29yayB9KTtcbiAgICAgIGxldCBjb252ZXJ0ZWRBcmdzO1xuICAgICAgaWYgKGZlZVBheWVyICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IG5vcm1hbGl6ZVBheWxvYWRGb3JJQyhhcmdzLnBheWxvYWQsIGFwdG9zQ29uZmlnKTtcbiAgICAgICAgY29uc3QgcmF3VHhuID0gYXdhaXQgZ2VuZXJhdGVSYXdUcmFuc2FjdGlvbih7XG4gICAgICAgICAgYXB0b3NDb25maWcsXG4gICAgICAgICAgZmVlUGF5ZXJBZGRyZXNzOiBmZWVQYXllci5hZGRyZXNzLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGdhc1VuaXRQcmljZSxcbiAgICAgICAgICAgIG1heEdhc0Ftb3VudFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICBzZW5kZXI6IHNpZ25lckFkZHJlc3NcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnZlcnRlZEFyZ3MgPSB7XG4gICAgICAgICAgZmVlUGF5ZXJBdXRoZW50aWNhdG9yOiBmZWVQYXllci5hdXRoZW50aWNhdG9yLFxuICAgICAgICAgIHJhd1R4bjogbmV3IEZlZVBheWVyUmF3VHJhbnNhY3Rpb24ocmF3VHhuLCBbXSwgZmVlUGF5ZXIuYWRkcmVzcylcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBub3JtYWxpemVQYXlsb2FkRm9ySUMoYXJncy5wYXlsb2FkKTtcbiAgICAgICAgY29udmVydGVkQXJncyA9IHtcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBleHBpcmF0aW9uVGltZXN0YW1wLFxuICAgICAgICAgICAgZ2FzVW5pdFByaWNlLFxuICAgICAgICAgICAgbWF4R2FzQW1vdW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXlsb2FkXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCB7IGhhc2ggfSA9IGF3YWl0IHRoaXMucGFpcmluZ0NsaWVudC5zaWduQW5kU3VibWl0VHJhbnNhY3Rpb24oc2lnbmVyQWRkcmVzcy50b1N0cmluZygpLCBjb252ZXJ0ZWRBcmdzLCB7XG4gICAgICAgIG5ldHdvcmtOYW1lOiBuZXR3b3JrXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBtYWtlVXNlckFwcHJvdmFsKHsgdHhuSGFzaDogaGFzaCB9KTtcbiAgICB9XG4gICAgY29uc3Qgc2VyaWFsaXplZFJlcXVlc3QgPSBTaWduQW5kU3VibWl0VHJhbnNhY3Rpb25SZXF1ZXN0LnNlcmlhbGl6ZSh0aGlzLmRhcHBJbmZvLCBhcmdzKTtcbiAgICBjb25zdCBzZXJpYWxpemVkUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZW5kUmVxdWVzdChzZXJpYWxpemVkUmVxdWVzdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBTaWduQW5kU3VibWl0VHJhbnNhY3Rpb25SZXNwb25zZS5kZXNlcmlhbGl6ZShzZXJpYWxpemVkUmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZS5hcmdzO1xuICB9XG4gIC8vIGVuZHJlZ2lvblxufTtcblxuLy8gc3JjL0lDRGFwcENsaWVudC50c1xuaW1wb3J0IHsgY3JlYXRlRWQyNTUxOUtleVBhaXIgYXMgY3JlYXRlRWQyNTUxOUtleVBhaXIyLCBlbmNvZGVCYXNlNjQgYXMgZW5jb2RlQmFzZTY0MyB9IGZyb20gXCJAaWRlbnRpdHktY29ubmVjdC9jcnlwdG9cIjtcbmltcG9ydCB7IGlzQXhpb3NFcnJvciBhcyBpc0F4aW9zRXJyb3IyIH0gZnJvbSBcImF4aW9zXCI7XG5cbi8vIHNyYy9wcm9tcHQudHNcbnZhciBERUZBVUxUX1BST01QVF9TSVpFID0geyBoZWlnaHQ6IDY5NSwgd2lkdGg6IDQ2NSB9O1xudmFyIFBST01QVF9QT0xMRVJfSU5URVJWQUwgPSA1MDA7XG5mdW5jdGlvbiBvcGVuUHJvbXB0KHVybCwgc2l6ZSA9IERFRkFVTFRfUFJPTVBUX1NJWkUpIHtcbiAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBzaXplO1xuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGhlaWdodCxcbiAgICBsZWZ0OiB3aW5kb3cuc2NyZWVuTGVmdCArIE1hdGgucm91bmQoKHdpbmRvdy5vdXRlcldpZHRoIC0gd2lkdGgpIC8gMiksXG4gICAgcG9wdXA6IHRydWUsXG4gICAgdG9wOiB3aW5kb3cuc2NyZWVuVG9wICsgTWF0aC5yb3VuZCgod2luZG93Lm91dGVySGVpZ2h0IC0gaGVpZ2h0KSAvIDIpLFxuICAgIHdpZHRoXG4gIH07XG4gIGNvbnN0IHN0ck9wdGlvbnMgPSBPYmplY3QuZW50cmllcyhvcHRpb25zKS5tYXAoKFtrZXksIHZhbHVlXSkgPT4gYCR7a2V5fT0ke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1gKS5yZWR1Y2UoKGFjYywgZW50cnkpID0+IGAke2FjY30sICR7ZW50cnl9YCk7XG4gIGNvbnN0IGhyZWYgPSB1cmwgaW5zdGFuY2VvZiBVUkwgPyB1cmwuaHJlZiA6IHVybDtcbiAgY29uc3QgcHJvbXB0V2luZG93ID0gd2luZG93Lm9wZW4oaHJlZiwgdm9pZCAwLCBzdHJPcHRpb25zKTtcbiAgaWYgKHByb21wdFdpbmRvdyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IG9wZW4gcHJvbXB0XCIpO1xuICB9XG4gIHJldHVybiBwcm9tcHRXaW5kb3c7XG59XG5hc3luYyBmdW5jdGlvbiB3YWl0Rm9yUHJvbXB0UmVzcG9uc2UocHJvbXB0V2luZG93KSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IHtcbiAgICAgIG9uTWVzc2FnZTogKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgaWYgKG1lc3NhZ2Uuc291cmNlICE9PSBwcm9tcHRXaW5kb3cpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVycy5vbk1lc3NhZ2UpO1xuICAgICAgICBjbGVhclRpbWVvdXQobGlzdGVuZXJzLnByb21wdFBvbGxlcklkKTtcbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgYXJnczogbWVzc2FnZS5kYXRhLFxuICAgICAgICAgIHN0YXR1czogXCJhcHByb3ZlZFwiXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHByb21wdFBvbGxlcklkOiBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9tcHRXaW5kb3cuY2xvc2VkKSB7XG4gICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGxpc3RlbmVycy5vbk1lc3NhZ2UpO1xuICAgICAgICAgIGNsZWFyVGltZW91dChsaXN0ZW5lcnMucHJvbXB0UG9sbGVySWQpO1xuICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgc3RhdHVzOiBcImRpc21pc3NlZFwiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0sIFBST01QVF9QT0xMRVJfSU5URVJWQUwpXG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgbGlzdGVuZXJzLm9uTWVzc2FnZSk7XG4gIH0pO1xufVxuXG4vLyBzcmMvSUNEYXBwQ2xpZW50LnRzXG52YXIgSUNEYXBwQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBBQ1BhaXJpbmdDbGllbnQge1xuICBjb25zdHJ1Y3RvcihkYXBwSWQsIHsgZnJvbnRlbmRCYXNlVVJMID0gREVGQVVMVF9GUk9OVEVORF9VUkwsIC4uLnBhaXJpbmdDbGllbnRDb25maWcgfSA9IHt9KSB7XG4gICAgc3VwZXIocGFpcmluZ0NsaWVudENvbmZpZyk7XG4gICAgdGhpcy5kYXBwSWQgPSBkYXBwSWQ7XG4gICAgdGhpcy5mcm9udGVuZEJhc2VVUkwgPSBmcm9udGVuZEJhc2VVUkw7XG4gIH1cbiAgYXN5bmMgY3JlYXRlUGFpcmluZ1JlcXVlc3QoZGFwcEVkMjU1MTlQdWJsaWNLZXlCNjQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmF4aW9zSW5zdGFuY2UucG9zdChcInYxL3BhaXJpbmcvXCIsIHtcbiAgICAgICAgZGFwcEVkMjU1MTlQdWJsaWNLZXlCNjQsXG4gICAgICAgIGRhcHBJZDogdGhpcy5kYXBwSWRcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGEuZGF0YS5wYWlyaW5nO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGlzQXhpb3NFcnJvcjIoZXJyKSAmJiBlcnIucmVzcG9uc2U/LmRhdGE/Lm1lc3NhZ2UgPT09IFwiRGFwcCBub3QgZm91bmRcIikge1xuICAgICAgICB0aHJvdyBuZXcgVW5yZWdpc3RlcmVkRGFwcEVycm9yKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG4gIC8vIHJlZ2lvbiBQdWJsaWMgQVBJXG4gIC8qKlxuICAgKiBSZXF1ZXN0cyBhIGNvbm5lY3Rpb24gdG8gYW4gYWNjb3VudCAoaW50ZXJuYWxseSBrbm93biBhcyBwYWlyaW5nKS5cbiAgICogQHJldHVybnMgZWl0aGVyIHRoZSBhZGRyZXNzIG9mIHRoZSBjb25uZWN0ZWQgYWNjb3VudCwgb3IgdW5kZWZpbmVkIGlmIHRoZVxuICAgKiBjb25uZWN0aW9uIHdhcyBjYW5jZWxsZWQuXG4gICAqL1xuICBhc3luYyBjb25uZWN0KCkge1xuICAgIGNvbnN0IHsgcHVibGljS2V5LCBzZWNyZXRLZXkgfSA9IGNyZWF0ZUVkMjU1MTlLZXlQYWlyMigpO1xuICAgIGNvbnN0IGRhcHBFZDI1NTE5UHVibGljS2V5QjY0ID0gZW5jb2RlQmFzZTY0MyhwdWJsaWNLZXkua2V5KTtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3RoaXMuZnJvbnRlbmRCYXNlVVJMfS9wYWlyaW5nYCk7XG4gICAgY29uc3QgcHJvbXB0V2luZG93ID0gYXdhaXQgb3BlblByb21wdCh1cmwuaHJlZik7XG4gICAgbGV0IHBhaXJpbmdJZDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGVuZGluZ1BhaXJpbmcgPSBhd2FpdCB0aGlzLmNyZWF0ZVBhaXJpbmdSZXF1ZXN0KGRhcHBFZDI1NTE5UHVibGljS2V5QjY0KTtcbiAgICAgIHBhaXJpbmdJZCA9IHBlbmRpbmdQYWlyaW5nLmlkO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbXB0V2luZG93LmNsb3NlKCk7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwicGFpcmluZ0lkXCIsIHBhaXJpbmdJZCk7XG4gICAgcHJvbXB0V2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmwuaHJlZjtcbiAgICBjb25zdCBwcm9tcHRSZXNwb25zZSA9IGF3YWl0IHdhaXRGb3JQcm9tcHRSZXNwb25zZShwcm9tcHRXaW5kb3cpO1xuICAgIGlmIChwcm9tcHRSZXNwb25zZS5zdGF0dXMgPT09IFwiZGlzbWlzc2VkXCIpIHtcbiAgICAgIHZvaWQgdGhpcy5kZWxldGVQYWlyaW5nKHBhaXJpbmdJZCwgc2VjcmV0S2V5LCBwdWJsaWNLZXkpO1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgZmluYWxpemVkUGFpcmluZyA9IHByb21wdFJlc3BvbnNlLmFyZ3M7XG4gICAgYXdhaXQgdGhpcy5hZGRQYWlyaW5nKHsgcHVibGljS2V5LCBzZWNyZXRLZXkgfSwgZmluYWxpemVkUGFpcmluZyk7XG4gICAgcmV0dXJuIGZpbmFsaXplZFBhaXJpbmcuYWNjb3VudC5hY2NvdW50QWRkcmVzcztcbiAgfVxuICBhc3luYyBvZmZib2FyZChhZGRyZXNzKSB7XG4gICAgY29uc3QgcGFpcmluZyA9IGF3YWl0IHRoaXMuYWNjZXNzb3JzLmdldChhZGRyZXNzKTtcbiAgICBpZiAocGFpcmluZyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGFjY291bnQgaXMgbm90IHBhaXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2FsbGV0SWQgPSBwYWlyaW5nLmRhcHBXYWxsZXRJZDtcbiAgICBpZiAod2FsbGV0SWQgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBhY2NvdW50IGNhbm5vdCBiZSBvZmZib2FyZGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke3RoaXMuZnJvbnRlbmRCYXNlVVJMfS9vZmZib2FyZGluZz93YWxsZXRJZD0ke3dhbGxldElkfWApO1xuICAgIGNvbnN0IHByb21wdFdpbmRvdyA9IG9wZW5Qcm9tcHQodXJsKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHdhaXRGb3JQcm9tcHRSZXNwb25zZShwcm9tcHRXaW5kb3cpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IFwiYXBwcm92ZWRcIiAmJiByZXNwb25zZS5hcmdzLm9mZmJvYXJkZWQpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdChhZGRyZXNzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gZW5kcmVnaW9uXG59O1xuXG4vLyBzcmMvS2V5bGVzc0NsaWVudC50c1xuaW1wb3J0IHtcbiAgQ29ubmVjdFJlcXVlc3QgYXMgQ29ubmVjdFJlcXVlc3QyLFxuICBDb25uZWN0UmVzcG9uc2UgYXMgQ29ubmVjdFJlc3BvbnNlMixcbiAgRGlzY29ubmVjdFJlcXVlc3QgYXMgRGlzY29ubmVjdFJlcXVlc3QyLFxuICBHZXRDb25uZWN0ZWRBY2NvdW50c1JlcXVlc3QgYXMgR2V0Q29ubmVjdGVkQWNjb3VudHNSZXF1ZXN0MixcbiAgR2V0Q29ubmVjdGVkQWNjb3VudHNSZXNwb25zZSBhcyBHZXRDb25uZWN0ZWRBY2NvdW50c1Jlc3BvbnNlMixcbiAgSXNDb25uZWN0ZWRSZXF1ZXN0LFxuICBJc0Nvbm5lY3RlZFJlc3BvbnNlLFxuICBTaWduQW5kU3VibWl0VHJhbnNhY3Rpb25SZXF1ZXN0IGFzIFNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvblJlcXVlc3QyLFxuICBTaWduQW5kU3VibWl0VHJhbnNhY3Rpb25SZXNwb25zZSBhcyBTaWduQW5kU3VibWl0VHJhbnNhY3Rpb25SZXNwb25zZTIsXG4gIFNpZ25NZXNzYWdlUmVxdWVzdCBhcyBTaWduTWVzc2FnZVJlcXVlc3QyLFxuICBTaWduTWVzc2FnZVJlc3BvbnNlIGFzIFNpZ25NZXNzYWdlUmVzcG9uc2UyLFxuICBTaWduVHJhbnNhY3Rpb25SZXF1ZXN0IGFzIFNpZ25UcmFuc2FjdGlvblJlcXVlc3QyLFxuICBTaWduVHJhbnNhY3Rpb25SZXNwb25zZSBhcyBTaWduVHJhbnNhY3Rpb25SZXNwb25zZTJcbn0gZnJvbSBcIkBhcHRvcy1jb25uZWN0L3dhbGxldC1hcGlcIjtcbmltcG9ydCB7IFdlYldhbGxldFRyYW5zcG9ydCBhcyBXZWJXYWxsZXRUcmFuc3BvcnQyIH0gZnJvbSBcIkBhcHRvcy1jb25uZWN0L3dlYi10cmFuc3BvcnRcIjtcbmltcG9ydCB7IE5ldHdvcmtOYW1lIGFzIE5ldHdvcmtOYW1lMyB9IGZyb20gXCJAaWRlbnRpdHktY29ubmVjdC9hcGlcIjtcbnZhciBBQ0tleWxlc3NDbGllbnQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBkYXBwSW1hZ2VVUkksXG4gICAgZGFwcE5hbWUsXG4gICAgZGVmYXVsdE5ldHdvcmtOYW1lID0gTmV0d29ya05hbWUzLk1BSU5ORVQsXG4gICAgZnJvbnRlbmRCYXNlVVJMID0gREVGQVVMVF9GUk9OVEVORF9VUkwsXG4gICAgcHJvdmlkZXIgPSBcImdvb2dsZVwiXG4gIH0gPSB7fSkge1xuICAgIHRoaXMuZGVmYXVsdE5ldHdvcmtOYW1lID0gZGVmYXVsdE5ldHdvcmtOYW1lO1xuICAgIHRoaXMuZGFwcEluZm8gPSB7XG4gICAgICBkb21haW46IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4sXG4gICAgICBpbWFnZVVSSTogZGFwcEltYWdlVVJJLFxuICAgICAgbmFtZTogZGFwcE5hbWUgPz8gZG9jdW1lbnQudGl0bGVcbiAgICB9O1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbmV3IFdlYldhbGxldFRyYW5zcG9ydDIoZnJvbnRlbmRCYXNlVVJMLCBwcm92aWRlcik7XG4gIH1cbiAgLy8gcmVnaW9uIFB1YmxpYyBBUElcbiAgYXN5bmMgaXNDb25uZWN0ZWQoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFJlcXVlc3QgPSBJc0Nvbm5lY3RlZFJlcXVlc3Quc2VyaWFsaXplKHRoaXMuZGFwcEluZm8pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnNlbmRSZXF1ZXN0KHNlcmlhbGl6ZWRSZXF1ZXN0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IElzQ29ubmVjdGVkUmVzcG9uc2UuZGVzZXJpYWxpemUoc2VyaWFsaXplZFJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuYXJncztcbiAgfVxuICBhc3luYyBnZXRDb25uZWN0ZWRBY2NvdW50cygpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUmVxdWVzdCA9IEdldENvbm5lY3RlZEFjY291bnRzUmVxdWVzdDIuc2VyaWFsaXplKHRoaXMuZGFwcEluZm8pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnNlbmRSZXF1ZXN0KHNlcmlhbGl6ZWRSZXF1ZXN0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IEdldENvbm5lY3RlZEFjY291bnRzUmVzcG9uc2UyLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRSZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlLmFyZ3M7XG4gIH1cbiAgYXN5bmMgZGlzY29ubmVjdCgpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkUmVxdWVzdCA9IERpc2Nvbm5lY3RSZXF1ZXN0Mi5zZXJpYWxpemUodGhpcy5kYXBwSW5mbyk7XG4gICAgYXdhaXQgdGhpcy50cmFuc3BvcnQuc2VuZFJlcXVlc3Qoc2VyaWFsaXplZFJlcXVlc3QpO1xuICB9XG4gIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFJlcXVlc3QgPSBDb25uZWN0UmVxdWVzdDIuc2VyaWFsaXplKHRoaXMuZGFwcEluZm8pO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnNlbmRSZXF1ZXN0KHNlcmlhbGl6ZWRSZXF1ZXN0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IENvbm5lY3RSZXNwb25zZTIuZGVzZXJpYWxpemUoc2VyaWFsaXplZFJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuYXJncztcbiAgfVxuICBhc3luYyBzaWduTWVzc2FnZShhcmdzKSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZFJlcXVlc3QgPSBTaWduTWVzc2FnZVJlcXVlc3QyLnNlcmlhbGl6ZSh0aGlzLmRhcHBJbmZvLCBhcmdzKTtcbiAgICBjb25zdCBzZXJpYWxpemVkUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZW5kUmVxdWVzdChzZXJpYWxpemVkUmVxdWVzdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBTaWduTWVzc2FnZVJlc3BvbnNlMi5kZXNlcmlhbGl6ZShzZXJpYWxpemVkUmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZS5hcmdzO1xuICB9XG4gIGFzeW5jIHNpZ25UcmFuc2FjdGlvbihhcmdzKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZEFyZ3MgPSBcInRyYW5zYWN0aW9uXCIgaW4gYXJncyA/IFNpZ25UcmFuc2FjdGlvblJlcXVlc3QyLm5vcm1hbGl6ZUFyZ3MoYXJncykgOiBhcmdzO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXF1ZXN0ID0gU2lnblRyYW5zYWN0aW9uUmVxdWVzdDIuc2VyaWFsaXplKHRoaXMuZGFwcEluZm8sIG5vcm1hbGl6ZWRBcmdzKTtcbiAgICBjb25zdCBzZXJpYWxpemVkUmVzcG9uc2UgPSBhd2FpdCB0aGlzLnRyYW5zcG9ydC5zZW5kUmVxdWVzdChzZXJpYWxpemVkUmVxdWVzdCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBTaWduVHJhbnNhY3Rpb25SZXNwb25zZTIuZGVzZXJpYWxpemUoc2VyaWFsaXplZFJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2UuYXJncztcbiAgfVxuICBhc3luYyBzaWduQW5kU3VibWl0VHJhbnNhY3Rpb24oYXJncykge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXF1ZXN0ID0gU2lnbkFuZFN1Ym1pdFRyYW5zYWN0aW9uUmVxdWVzdDIuc2VyaWFsaXplKHRoaXMuZGFwcEluZm8sIGFyZ3MpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRSZXNwb25zZSA9IGF3YWl0IHRoaXMudHJhbnNwb3J0LnNlbmRSZXF1ZXN0KHNlcmlhbGl6ZWRSZXF1ZXN0KTtcbiAgICBjb25zdCByZXNwb25zZSA9IFNpZ25BbmRTdWJtaXRUcmFuc2FjdGlvblJlc3BvbnNlMi5kZXNlcmlhbGl6ZShzZXJpYWxpemVkUmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZS5hcmdzO1xuICB9XG4gIC8vIGVuZHJlZ2lvblxufTtcbmV4cG9ydCB7XG4gIEFDRGFwcENsaWVudCxcbiAgQUNLZXlsZXNzQ2xpZW50LFxuICBEQVBQX1BBSVJJTkdTX1dJTkRPV19TVE9SQUdFX0tFWSxcbiAgSUNEYXBwQ2xpZW50LFxuICB3aW5kb3dTdGF0ZUFjY2Vzc29yc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@identity-connect+dapp-sdk@0.10.0_@aptos-labs+ts-sdk@1.30.0_@aptos-labs+wallet-standard@0.2.0_erosxk4jpck6vdia6mixqdmoqa/node_modules/@identity-connect/dapp-sdk/dist/index.mjs\n");

/***/ })

};
;